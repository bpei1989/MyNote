第一章 了解SQL
理解数据库最简单的办法是将其想象成一个文件柜，数据库是一种保存有组织数据的容器
数据库管理系统，DBMS，可以创建和操作数据库，你并不直接访问数据库，而是使用DBMS，替你访问数据库，不要混淆数据库和数据库管理系统，MySQL是一个关系型数据库管理系统

表是一种结构化文件，类似于文件柜中的文件
表由一个或多个列组成，列（column）表中的一个字段，每个列都有数据类型（datatype）限制该列存储的数据
行（row）表中的一个记录

主键（primary key）一列（或一组列），它的值能区分表中的每行，虽然并不总是需要主键，但是应该保证每个表具有一个主键，以便于操纵和管理。
任何列都可以作为主键，只要满足以下两个条件：任意两行都不具有相同的主键值；每行都必须具有一个主键值（主键值不允许为NULL）
主键通常定义在表的一列上，也可以用多个列作为主键，在使用多列作为主键时，所有列值得组合必须是唯一的（单列的值可以不唯一）
主键的最好习惯：不更新主键列中的值，不重用主键列中的值，不在主键中用可能会更改的值。（注：一般是ID为主键，符合所有要求）

SQL是专门用于与数据库通信的语言


第二章 MySQL简介
MySql是一种DBMS，C/S结构的数据库，Client用于提交请求，Server负责处理请求（增删改查）
mysql --help获取各种用法
连接mysql -u ben -p -h myserver -P 9999

其他图形界面client： MySQL Administrator， MySQL Query Browser


第三章 使用MySQL
连接需要主机名（本地为localhost），端口，用户名，密码
(关键字大写，这样有助于阅读)

可用的数据库列表
SHOW DATABASES;

用crashcourse数据库
USE crashcourse;

显示数据库内的可用的列表
SHOW TABLES;

显示表中的列的详细信息，对各个字段返回一行，行中包含字段名，数据类型，是否允许为NULL，键信息，默认值，其他信息（如auto_inrement）
SHOW COLUMNS FROM customers;
某些表列需要唯一值，比如订单号，而且自增，这样可以在CREATE表时包含该关键字

SHOW COLUMNS的快捷方式
DSCRIBE customers;

其他SHOW
SHOW STATUS，用于显示服务器状态信息
SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句
SHOW GRANTS,用来显示用户的安装权限
SHOW ERRORS和SHOW WARNINGS，用来显示错误和警告信息

HELP SHOW，显示允许的SHOW语句


第四章 检索数据
SELECT prod_name
FROM products;
从表中查询列，注意如果在不同的电脑上可能结果不同，因为如果没有明确查询结果，则返回的数据的顺序没有特殊意义，返回的数据可能是数据被添加到表中的顺序，也可能不是，只要返回相同数目的行，就是正常的
多条SQL必须加分号，但单条有的可以不加，但事实上总是加上分号是没坏处的
SQL不区分大小写，但是所有列和表明使用小写，所有关键字大写，这样易读
处理SQL时，所有空格都会被忽略，所以可以一行也可以多行，多行容易阅读
(例子中的所有SQL都是分行的，基本是以FROM等关键字分割的)

检索多个列
SELECT prod_id, prod_name, prod_price
FROM products;
SQL查询结果一般是无格式的数据，比如9，实际上是9块钱，但钱的符号不会存在数据库里，都是应用程序取出来再处理的

显示所有列
SELECT *
FROM products;
一般除非真的需要每个列，否则*会降低性能，通配符可以检索出名字未知的列

检索不同的行
SELECT DISTINCT vend_id
FROM products;
注意DISTINCT必须在列前面，只显示不同的行，去重，DISTINCT对所有列有限，而不仅是最前面的列，SELECT DISTINCT vend_id, prod_price;除非两列都不同，否则将显示所有行

限制结果
SELECT prod_name
FROM products
LIMIT 5;
返回不多于5行，为了获取下一个5行，可指定开始行和行数
SELECT prod_name
FROM products
LIMIT 5,5;
注意：检索出来的第一行为行0而不是1，LIMIT 1,1结果是第二行
行数不够时有多少返回多少
LIMIT 4 OFFSET 3（易读）是从第三行起曲四行，等价于LIMIT 3,4

使用完全限定的表名
完全限定的名字来引用列，同时使用表名和列
SELECT products.prod_name
FROM products;

SELECT products.prod_name
FROM crashcourse.products;
限定数据库的表
这种写法在某些情形有用，后面会介绍


第五章 排序检索数据
检索出的结果一般和表中顺序一致，但更新或删除过，则顺序会受到影响
SELECT prod_name
FROM products
ORDER BY prod_name;
对prod_name列以字母顺序排序
注：一般ORDER BY的列是显示所选择的列，但实际中用非检索的列排序是完全合法的

按多个列排序
检索3个列，按其中两个列对结果进行排序，首先按价格，再按名称排序
SELECT prod_id, prod_price, prod_name
FROM products
ORDER BY prod_price, prod_name;
如果多行具有相同的prod_price时，再按prod_name排序，如果prod_price没有重复的值，则不会按prod_name排，这点要注意

指定排序方向
降序DESC
SELECT prod_id, prod_price, prod_name
FROM products
ORDER BY prod_price DESC;

SELECT prod_id, prod_price, prod_name
FROM products
ORDER BY prod_price DESC, prod_name;
这个语句只会对prod_price进行DESC，prod_name在每个相同的价格内还是按升序
如果想在多列上降序排序，不许对每个列都指定DESC关键字
ASC是升序，但是一般不用因为默认是升序
如果要区分大小写排序，默认不区分大小写，ORDER BY语句做不到，只能改数据库配置

ORDER BY与LIMIT组合找出最值
SELECT prod_price
FROM products
ORDER BY prod_price DESC
LIMIT 1
返回最贵的
注：OERDER BY子句必须位于FROM子句后面，LIMIT必须位于ORDER BY后面，否则结果有问题


第六章 过滤数据
WHERE子句
WHERE可以指定搜索条件，WHERE子句在FROM之后
SELECT prod_name, prod_price
FROM products
WHERE prod_price = 2.50;
在同时用ORDER BY和WHERE时，ORDER BY位于WHERE之后（注：可以想，必须先知道顺序才能LIMIT，如果要知道顺序，必须知道排列的集合，要知道排列的集合，则必须知道筛选条件WHERE，而WHERE切都必须依赖于SELECT）

WHERE子句
=	等于
<>	不等于
!=	不等于
<	>	<=	>=
BETWEEN	在两个值之间

SELECT prod_name, prod_price
FROM products
WHERE prod_name = 'fuses'
不区分大小写，Fuses和fuses相同

SELECT prod_name, prod_price
FOMR products
WHERE prod_price <= 10;
搜索小于等于10块钱的物品

SELECT vend_id, prod_name
FROM products
WHERE vend_id <> 1003;
还可用!=
列出不是供应商ID为1003制造的产品

注：单引号用来限定字符串，如果将值与字符串比较，则需要限定单引号，用来与数字比较则不用

SELECT prod_name, prod_price
FOMR products
WHERE prod_price BETWEEN 5 AND 10;
注：匹配BETWEEN必须用AND，而且结果包括5和10

SELECT prod_name
FROM products
WHERE prod_price IS NULL;
空值查找
查找电子邮件为空的客户
SELECT cust_id
FROM customers
WHERE cust_email IS NULL;


第七章 数据过滤
AND操作符
SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1003 AND prod_price <= 10;
如果有多个条件则每多一个加一个AND

OR操作符
SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1002 OR vend_id = 1003;
多一个条件加一个OR

AND优先于OR
SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price >= 10;
结果是返回vend_id为1002或1003并且大于等于10，即>=10只对1003起作用，因为AND的优先于OR
圆括号可以解决优先级问题
SELECT prod_id, prod_price, prod_name
FROM products
WHERE （vend_id = 1002 OR vend_id = 1003） AND prod_price >= 10;
注：任何涉及优先级的时候都必须用圆括号，增加可读性

IN操作符
SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002, 1003)
ORDER BY prod_name;
检索供应商ID为1002和1003的所有产品，IN后面跟由都喊分割的清单，整个清单都必须包括在圆括号中，IN和OR等价
用IN不用OR因为：IN语法清楚，IN比OR更快，IN的最大优点是可以包含其他SELECT语句，后面会介绍

NOT操作符
SELECT prod_name, prod_price
FROM products
WHERE vend_id NOT IN (1002, 1003)
ORDER BY prod_name;
用来否定后面的操作符
NOT支持对BETWEEN,IN,EXISTS否定


第八章 用通配符进行过滤
LIKE操作符
%表示任何字符出现任意次数
SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE'jet%';
结果：
prod_id prod_name
JP100	JetPack 1000
JP200	JetPack 2000
jet之后任意字符，不管有多少，搜索可以区分大小写(配置MySQL)，若区分大写，jet%与JetPack 100将不匹配

SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE'%anvi%';
结果
prod_id prod_name
ANVO1	.5 ton anvil
ANVO2	1 ton anvil
%anvi%任何包含anvi的字符串而不管它前面和后面，通配符可以在任何位置使用任意次，也可以用在中间（一般不怎么会放在中间）
注意： %通配符不能匹配NULL， WHERE prod_name LIKE '%'找不出NULL的行
末尾空格会干扰通配符，如anvil尾部有一个空格，则WHERE prod_name LIKE '%anvi'匹配不到它们，解决办法是在后面加一个%，或者更好的方法用函数去掉首尾空格

下划线通配符
匹配任意单个字符，与%类似
SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE'_ ton anvil';
.5 ton anvil不会匹配到，因为_只匹配单个字符

通配符使用技巧
不要过度使用通配符，如果其他操作能达到目的，尽量用其他操作
在确实需要用通配符时，除非绝对需要，否则不要把它们用在搜索的开始出，把通配符放在起始处会很慢
注意通配符的位置，大部分应该是在首尾


第九章 用正则表达式进行搜索
基本字符匹配
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '1000'
ORDER BY prod_name
匹配包含1000的所有prod_name，注意与LIKE的区别，如果prod_name是JA 1000，正则表达式会返回，LIKE不会，因为LIKE是匹配整个列，LIKE ‘1000’只能匹配1000，不能匹配JA 1000，这是正则表达式和LIKE的一个重要区别
默认正则表达式匹配不区分大小写，如果需要区分则用BINARY，如WHERE prod_name REGEXP BINARY 'JA .000'

OR
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '1000|2000'
ORDER BY prod_name
两个以上就是1000|2000|3000

匹配字符之一
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '[123] Ton'
ORDER BY prod_name;
[123]是匹配1或2或3，可匹配1 ton, 2 ton, 3 ton
可以把[]理解成OR的另一种形式
[123]Ton 等价于 [1|2|3]Ton,但是必须用[]
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '1|2|3 Ton'
ORDER BY prod_name;
匹配结果是
1 ton anvil
2 ton anvil
JetPack 1000
因为不加括号的意思是1或2或3 Ton，除非把|放在集合中，否则就是对整个字符串或
[^123]匹配这些字符之外的任何东西

匹配范围
[12345]为了简化一般用-代表一个范围
[0-9] [a-z]
SELECT prod_name
FROM products
WHERE prod_name REGEXP '[1-5] Ton'
ORDER BY prod_name
结果：
.5 ton anvil
1 ton anvil
...
注意.5也可以匹配，因为正则表达式会匹配在其中的意思，而不是LIKE匹配整个，.5 ton anvil包含[1-5] Ton，
不用写.[1-5] Ton*，MySQL中的正则表达式和正常语言中的稍有不同

匹配特殊字符
反斜杠，\,一个不行，需要两个\\,因为MySQL自己解释一个，另一个给正则表达式（其实Java也是这样）
SELECT prod_name
FROM products
WHERE prod_name REGEXP '.'
ORDER BY prod_name
所有非空大于等于一个字符的都显示出来了，注意MySql正则的特殊，是包含关系，REGEXP后面的只要包含在结果里就能匹配
SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\.'
ORDER BY prod_name
有点的匹配到，必须用两个反斜杠
特殊字符|,[]等都必须这样，如果匹配反斜杠则\\\
\\n 换行
\\t 制表
\\r 回车
'\r' 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；
'\n' 换行，换到当前位置的下一行，而不会回到行首

[:alnum:]数字和字母，[:alpha:]任意字母
还有很多其他的，用时可以查

*	0或多个
+	1或多个
?	0或1个
{n}	匹配n次
{n,}匹配不少于n次
{n,m}匹配范围，m不超过255

匹配多个实例
SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\([0-9] sticks?\\)'
ORDER BY prod_name;
结果：
TNT (1 stick)
TNT (5 sticks)
\\匹配括号，转义，0-9匹配数字，?匹配0或1个字符

SELECT prod_name
FROM products
WHERE prod_name REGEXP '[[:digit:]]{4}'
ORDER BY prod_name;
匹配连续4个数字，[:digit:]匹配单个数字，由于是集合，{4}匹配次数，所以[[:digit:]]{4}
注意正则表达式通常有多种写法，上面还可以写成'[0-9][0-9][0-9][0-9]'
(注解：如果比较高级的写法不会的话，就用清楚的写法，比如[0-9][0-9][0-9][0-9]，或[0-9]{4},[[]]双括号，可能比较不好想)

定位符
^	文本的开始
$	文本的结尾
[[:<:]]	词的开始
[[:>:]]	词的结尾
搜索小数点开始的数字，用[0-9\\.]不行，必须用^
SELECT prod_name
FROM products
WHERE prod_name REGEXP '^[0-9\\.]'
ORDER BY prod_name;
搜索0-9或.开始的，而不是0-9接着. 因为[]表示一个集合

注意^在集合中的意思是否定该集合，[^0-3],否则意思为字符串的开始处
LIKE和REGEXP不同在于，LIKE匹配整个串二REGEXP匹配子串，利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样
用SELECT来测试正则表达式（不用数据库）
SELECT 'hello' REGEXp '[0-9]'; 返回0，因为不匹配，如果匹配返回1，这个可以检查正则表达能不能用，先检查再用比较好


第十章 创建计算字段
数据库表中的数据一般不是想要的格式，比如，实际中想要公司名加逗号加公司ID，这时需要直接从数据中检索，然后转换
字段基本上与列的意思一样，只不过表中称列，在计算中一般称字段
很多转格式工作在Client也可以完成，不过一般都会让服务器完成，因为DBMS优化过，处理这些更快

拼接字段
concatenate，拼接，把值拼接到一起构成单个值

SELECT Concat(vend_name, '(', vend_country, ')')
FROM vendors
ORDER BY vend_name;
结果：
Concat(vend_name, '(', vend_country, ')')
ACME (USA)
Jouets Et (France)
注意：很多DBMS会用+或||实现拼接，Mysql则是用Concat()函数，这点要记住
Concat()把多个串连接起来形成一个长串，Concat()需要一个或多个指定的串，用逗号分隔

删除右侧多余空格
SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')')
FROM vendors
ORDER BY vend_name;
RTrim()函数去掉值右边的所有空格，还支持LTrim()清除左边的空格，Trim清楚左右的空格

别名
前面的例子中，Concat后的字段不好查询，可以起一个alias来替换，用关键字AS
SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS
vend_titile
FROM vendors
ORDER BY vend_name;
结果：
vend_titile
ACME (USA)
Jouets Et (France)
现在，列名为vend_title，可以按这个名字引用此列
别名还有其他用途，包括对列表名含有不符合规定的字符，如空格，对其重命名，或在原来名字起的不好时重新扩充

SELECT prod_id, quantity, item_price,
	quantity*item_price AS expanded_price
FROM orderitems
WHERE order-num = 20005;
检索结果计算(支持加减乘除)，新列命名，结果
prod_id quantity item_price expanded_price
...

测试： SELECT 2*3；返回6
SELECT Trim(' abc ');返回abc
SELECT Now(); 返回当前时间
用SELECT可以在不用数据库的情况下测试，防止错误，和上一章类似


第十一章 使用数据处理函数
SQL一般支持如下函数：
处理文本，比如删除，大小写转换
算数，比如加减乘除，绝对值
日期时间，比如两日期之差
DBMS信息，比如用户登录信息，版本信息

文本处理函数
Upper函数,转大写
SELECT vend_name, Upper(vend_name) AS vend_name_upcase
FROM vendors
ORDER BY vend_name;
结果
vend_name 	vend_name_upcase
...

常用的文本处理函数
Left()	返回串左边的字符
Length()	返回串的长度
Locate()	返回串的一个子串
Lower()	返回串的小写形式
LTrim()	去掉左边空格
Right()	返回串右边的字符
RTrim()	去掉串右边的空格
Soundex()	返回串的Soundex模式，SOUNDEX(str)从str返回一个soundex字符串。两个字符串应该有几乎是相同的同音字符串
SubString()	返回子串
Upper()	转换为大写形式

SELECT cust_name, cust_contact
FROMｃｕｓｔｏｍｅｒｓ
ＷＨＥＲＥ　Ｓｏｕｎｄｅｘ（ｃｕｓｔ_contact) = Soundex('Y Lie');
结果
cust_name cust_contact
Coyote		Y Lee
Lee不是Lie，但是发音类似，所以可以搜索，注意函数的用法，这些函数就像加减乘除一样，可以在任意地方使用

日期和时间
AddDate()	增加一个日期（天，周等），注意日期是2015-01-01，不是时间，10:11:01
AddTime()	增加一个时间（时，分）
CurDate()	返回当前日期
CurTime()	返回当前时间
Date()		返回日期时间的日期部分，比如2015-01-01 10:11:01返回2015-01-01
DateDiff()	就是两个日期之差
Date_Add()	日期运算函数
Date_Format()	返回一个格式化的日期时间字符串
Day()	返回一个日期的天数部分
DayOfWeek()	传入一个日期，返回星期几
Hour()	返回一个时间的小时部分
Minute()	返回一个时间的分钟部分
Month()	返回一个时间的月部分
Now()	返回当前日期和时间
Second()	返回一个时间的秒部分
Time()	返回一个日期时间的的数据部分
Year()	返回一个日期的年部分

如果用日期则必须用四位数的年，虽然79,81可以被解析为1979等，但是不好
SELECT cuts_id, order_num
FROM orders
WHERE order_date = '2005-09-01';
其实这种写法不太好，如果订单是2005-09-01 11:09:01就匹配不到，所以不要这么写，之所以写在这是当反例的

SELECT cuts_id, order_num
FROM orders
WHERE Date(order_date) = '2005-09-01';
如果比较日期，用Date，这样拿出日期部分，忽略时间，可以直接用=比较，后面直接写成'xxxx-xx-xx'，即使数据库表的格式是datetime
类似还有Time(order_date)

SELECT cuts_id, order_num
FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
可用，但是不好，用下面的

SELECT cuts_id, order_num
FROM orders
WHERE Year(order_date) = 2005 AND Month(order_date) = 9;
注：要优先用函数来操作，而不是直接比较，取出时直接用函数操作后再进行比较

数字处理函数
Abs（）	返回绝对值
Exp指数， Mod求余 Rand随机


第十二章 汇总数据
AVG 平均， COUNT 行数， MAX 最大值， MIN 最小， SUM 和，所有参数都是某列，注意函数的参数一般是列名，包括其他函数，文本处理，时间函数等

SELECT AVG(prod_price) AS avg_price
FROM products;
返回所有产品的平均价格

SELECT AVG(prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
具体某个提供商的平均价格
AVG()只能用于一个列的平均，列名为参数，如果需要获得多个列则需要多个AVG，AVG会忽略值是NULL的行

SELECT COUNT(*) AS num_cust
FROM customers;
查询表中客户的总数

SELECT COUNT(cust_email) AS num_cust
FROM customers;
有email的客户总数
如果指定列名，则其中值为NULL的会忽略，如果COUNT(*)则不会忽略NULL,所以上面那个可以查所有用户个数，而下面这个只能查有email

SELECT MAX(prod_price) AS max_price
FROM products;
最贵的产品，MAX通常用于查找数值和时间，但是也可以查找其他的，比如字符串，不过不常用，MAX会忽略NULL

MIN与MAX用法一样，只不过意思相反

SELECT SUM(quantity) AS items_ordered
FROM orderitems
WHERE order_num = 2005;
返回订单号为2005的物品数量之和
SUM可以进行数值计算，忽略NULL行
SELECT SUM(item_price*quantity) AS total_price
FROM orderitems
WHERE order_num = 2005;
注意这个把item_price和quantity都select出来了，然后做运算，SUM可以选择多行做运算

SELECT AVG(DISTINCT prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
只筛选不同的做平均，默认是ALL，所有的都算，不用写明
DISTINCT只能用于具体行，不能用于*和运算，比如COUNT(DISTINCT *)不合法，必须COUNT(DISTINCT col_name)
理论上可以用于MAX和MIN，不过没有意义

组合
SELECT COUNT(*) AS num_items,
	MIN(prod_price) AS price_min,
	MAX(prod_price) AS price_max,
	AVG(prod_price) AS price_avg
FROM products;
结果
num_items price_min price_max price_avg
...
这个例子用于把表的各种指数筛选出来，还用了各种函数，注意别名的用法，这种时候不要用原来的列名，因为会引起歧义，这就是别名的用处
注：务必使用函数，这些SQL内置函数都是专业优化过的，效率高，易读，不出错


第十三章 数据分组
分组允许把数据分成多个组，以便对每个组进行计算
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id
结果
vend_id	num_prods
1001	3
1002	2
...
可以理解为：对不同vend_id分别进行COUNT(*)，分组其实就是把函数精确化到以某个列作为区分，比如各国人口，就是country这个列进行GROUP BY，然后COUNT（num）
注意GROUP BY会只是Mysql分组数据，然后对每个组使用函数，如COUNT，而不是对整个结果使用
SELECT出vend_id才可能用GROUP BY，不能没SELECT vend_id而用GROUP BY vend_id，还有AS是针对一个的，如只针对COUNT(*),如果vend_id需要，则再加一个AS，vend_id AS xxx

GROUP BY注意事项：
1.GROUP BY子句可以包含任意数目的列，这就能对分组进行嵌套
2.如果在GROUP BY子句中嵌套分组，数据会在最后规定的分组上汇总，建立分组时，指定的所有列都一起计算（没太明白，可以试试）
3.GROUP BY子句中的每个列都必须是检索列（SELECT出来的）或有效表达式（不能是聚集函数，这个可以理解，因为如果是COUNT之类的函数，那就没法GROUP BY了，GROUP BY必须根据数据库中的表中的原始数据进行，而不是中间数据），如果SELECT用了表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名（同样的原因，别名没在表的原始数据中，它只是个中间结果）
4.除了聚集计算语句，SELECT语句中的每个列都必须在GROUP BY子句中给出
5.如果分组有多个NULL，则NULL将作为一个分组返回（分组就是GROUP BY时某列具有相同值的行组成的一个组）
6.GROUP BY子句必须出现在WHERE子句后面，ORDER BY子句前面（好理解，只有分好组才能排序）

WITH ROLLUP可以得到每个分组的级别值（不太清楚，可以试试）
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id WITH ROLLUP;

过滤分组
HAVING，与WHRER乐死，所有的WHERE子句都可以用HAVING代替，唯一的差别就是WHERE过滤行，HAVING过滤分组，所以GROUP BY的结果再进行限定，比如订单大于两个的用户，就用HAVING，而不能用WHERE
SELECT cust_id, COUNT(*) AS orders
FROM orders
GROUP BY cust_id
HAVING COUNT(*) > 2;
对cust_id进行分组之后再进行COUNT(*)操作算出各个分组的订单数，之后再对分组的结果进行筛选，HAVING和WHERE唯一别是HAVING针对分组，如果这里用WHERE则不起作用，因为WHERE针对行

HAVING和WHERE区别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤，WHERE排除的行不包括在分组中，HAVING子句基于WHERE排除后形成的分组进行过滤
SELECT vend_id, COUNT(*) AS num_prods
FROM products
WHERE prod_price >= 10
GROUP BY vend_id
HAVING COUNT(*) >= 2;
列出含有2个及以上，价格大于等于10的产品供应商，价格大于10显然是对于原始数据的，行，所以用WHERE，提供两个以上商品的则需要GROUP BY，GROUP BY vend_id,基于COUNT(*),正是因为基于COUNT(*)所以才能用HAVING COUNT(*) >= 2过滤
如果不加WHERE过滤则全部原始数据都参加分组，WHERE针对原始数据过滤，HAVING基于分组（注：估计由于原始数据也是一种分组，即每个一组，所以HAVING可以代替WHERE）

分组和排序
GROUP BY和ORDER BY虽然有时能完成相同的工作，但是两者实际不同
GROUP BY                                                             ORDER BY
分组，单输出可能不是分组的顺序（可能不按序输出）                          按序
只能用SELECT出的列或SELECT的表达式列（正则筛选的列）                     任意列，可以ORDER BY没SELECT的列，还可以是别名
如果与聚集函数一起使用列，如COUNT(*)，则必须使用                         不一定用（可以理解为不关心是否使用了函数）
可以理解为由于ORDER BY本身就是对中间数据排序，所以不关心原始数据
使用GROUP BY时，同时要使用ORDER BY，保证顺序，GROUP BY不保证顺序（虽然一般按序，但是特殊情况不会，需要ORDER BY保障）

SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING SUM(quantity*item_price) >= 50;

SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING SUM(quantity*item_price) >= 50
ORDER BY ordertotal;
注：HAVING的筛选基本上一定是基于函数的，即SELECT的函数，GROUP BY 是基于SELECT里没有用函数的列，ORDER BY什么也不基于，随便哪一列都行，虽然如此但是还是最好基于SELECT里的列，可读性好的多

子句顺序
子句        说明                              是否必须使用
SELECT      要返回的列或表达式                 是
FROM        从中SELECT数据的表                 仅在需要从表中查询数据时
WHERE       行级别过滤                         否
GROUP BY    根据什么分组                       仅在按组计算时用
HAVING      组级别过滤                         否
ORDER BY    排序                               否
LIMIT       限制检索的行数                      否


第十四章 使用子查询
利用子查询进行过滤
跨表查询，即一个表的查询结果是另一个语句的数据范围，一个组合
SELECT cust_id
FROM orders
WHERE order_num IN (SELECT order_num
					FROM　orderitems
					WHERE prod_id = 'TNT2');

子查询总是从内向外处理，实际上执行了两个操作，首先查询子查询，返回结果以列表形式返回，这时外部变成IN(result from subSelect)

SELECT cust_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
				  FROM orders
				  WHERE order_num IN (SELECT order_num
				  					  FROM orderitems
				  					  WHERE prod_id = 'TNT2'));
检索订购TNT2的客户信息，基于客户ID，而客户ID由基于子查询
注意：子查询可读性较差，适当的缩进换行可以提高可读性
还有如果是多行的话，WHERE需要注意,WHERE子句中列数和子查询返回的列数相同才行，一对一
一般子查询都用IN，也可以用=，<>等

计算字段子查询
从customers表中检索客户列表，对于检索出的每个客户，统计其在orders表中的订单数目
SELECT cust_name,
	   cust_state,
	   (SELECT COUNT(*)
	    FROM orders
	    WHERE orders.cust_id = customers.cust_id) AS orders
FROM customers
ORDER BY cust_name;
结果：
cust_name cust_state orders
...
注意：子查询别名，子查询作为SELECT的一列，
orders.cust_id = customers.cust_id的意思是比较两个表中的字段，如果不限定就默认在orders表中对比，自己和自己比，所以需要限定，很重要

子查询的构建方式：用渐进测试来构建子查询，先建立和测试最内层的查询，然后用hard code数据建立和测试外城查询，并且再确认它正常工作后才嵌入子查询，在测试，这样做可以避免一下子写出来出了错，难以debug的情况


第十五章 联结（join）表
关系表
两张表通过主键关联
物品的信息和生产商的信息需要分别存在两张表里，因为如果放在一张表里的话，有大量重复，很多商品都是一个生产商提供的，在关系数据库里，大量的重复绝不是一件好事，若有大量重复，则必须把重复部分分成另一张表

供应商和商品分别存在两张表里的坏处（反过来就是分表的好处）
很多商品的供应商都是一样的，大量重复存储浪费空间
如果供应商信息改变，需要改动地方太多
大量重复数据有不一致的可能（人为的输错）

vendors表存储供应商，每个供应商占一行，用ID表示（主键），products表只存储产品信息，它除了存储供应商ID（vendors表的主键）之外，不存储其他任何供应商的信息
vendors的主键叫做products表的外键，它可以关联两个表，外键是表中的某一列，它包含另一个表的主键值，连接两张表，外键是个很重要的概念

可伸缩性：能不断适应增加的工作量，关系数据库的适应性优于非关系数据库

数据存在多个表中需要用联结来查询
联结，用来在一条SELECT语句中关联表
重要的是，需要理解联结不是物理实体，它在数据库表中不存在，它存在于查询执行当中
为了防止非法数据，即products里的供应商在vendors里查不到的情况，用指定主键和外键实现（这就是维护引用完整性）

创建联结
SELECT vend_name, prod_name, prod_price
FROM vendors, products
WHERE vendors.vend_id = products.vend_id
ORDER BY vend_name, prod_name;
注：prod_name，prod_price（这两个在同一个表）和vend_name不在一个表中，FROM有两个表，就是联结的两个表，这两个表通过WHERE联结，其中需要指定表明，vendors.vend_id = products.vend_id，这点一定要注意
联结实际上是将第一个表中的每一行与第二个表中的每一行对比，WHERE是行的过滤
没有联结（WHERE）的结果是表1和表2的笛卡尔积，即第一个表中的行数乘以第二个表中的行数
注意：不能忘记WHERE，否则结果就是笛卡尔积

内部联结
基于两个表之间的联结称内部联结或等值联结，可以用下面的语法
INNER JOIN两张表，ON表示条件（和WHERE相同，推荐用这种语法，更清晰说明用了联结，有时还能提高效率）
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id = products.vend_id;

联结多张表（用AND）
SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems, products, vendors
WHERE products.vend_id = vendors.vend_id
	AND orderitems.prod_id = products.prod_id
	AND order_num = 20005;
注意FROM和WHERE，WHERE中的表必须在FROM中。
显示20005订单的商品，订单存在orderitems表中，这些商品通过供应商ID联结到vendors表中相应的供应商，最后一个条件是过滤订单号，WHERE不光是联结，还可以通过AND增加行过滤条件，比如AND order_num = 20005
注：能不用联结多张表就不用，因为联结越多效率越低

SELECT cust_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
				  FROM orders
				  WHERE order_num IN (SELECT order_num
				  					  FROM orderitems
				  					  WHERE prod_id = 'TNT2'));
这个例子可以用联结
SELECT cust_name, cust_contact
FROM customers, orders, orderitems
WHERE customers.cust_id = orders.cust_id
	AND orderitems.order_num = orders.order_num
	AND prod_id = 'TNT2';
SELECT后面的行可以是包含在FROM表中的任何行，WHERE中的表也必须在FROM表里

注：一般一个操作可以用不止一种方法实现，但是性能会有差异，所以有必要对各种机制实验，找到合适的方法


第十六章 创建高级联结
使用表别名
除了可以给列起别名，还可以给表起别名，主要是因为：缩短SQL长度，允许单条SELECT语句中多次使用相同的表
SELECT cust_name, cust_contact
FROM customers AS c, orders AS o, orderitems AS oi
WHERE c.cust_id = o.cust_id
	AND oi.order_num = o.order_num
	AND prod_id = 'TNT2';
注意表别名不仅可以用于WHERE子句，还可以用于SELECT，ORDER BY等其他部分，表别名只在查询执行中时用，并不会显示在查询结果中，这与列别名不一样

使用不同类型的联结
自联结
如果查到某生产商的DTNTR商品有问题，想查下该生产商的其他商品：
SELECT prod_id, prod_name
FROM products
WHERE vend_id = (SELECT vend_id
				 FROM products
				 WHERE prod_id = 'DTNTR');
注意IN往往是外面那个与内部中的SELECT一样，如vend_id = (SELECT vend_id，都是vend_di
联结：
SELECT p1.prod_id, p1.prod_name
FROM products AS p1, products AS p2
WHERE p1.vend_id = p2.vend_id
	AND p2.prod_id = 'DTNTR';
注意，表别名的使用，查询中需要的两个表其实是同一张表，FROM中出现了两次，虽然合法，但有歧义，所以要把该表和自己联结，查找（有些不容易理解，弄不清就用IN，正确优先）
还有自联结的效率有时优于子查询，所以试一下两种方法，看哪个快

自然联结
自然联结是只能选择那些唯一的列，排除多次出现，每个列只显示一次
一般通过SELECT *通配符对其他表的列使用明确的子集来完成
SELECT c.*, o.order_num, o.order_date,
		oi.prod_id, oi_quantity, OI.item_price
FROM customers AS c, orders AS o, orderitems AS oi
WHERE c.cust_id = o.cust_id
	AND oi.order_num = o.order_num
	AND prod_id = 'FB';
这里通配符只对第一个表用，其他表用具体列（可以理解为自然联结就是普通联结，多个表，选择列，显示那些列）
注：联结的基本语法：
SELECT col1, col2, ...(来自不同的表)
FROM table1， table2, ...
WHERE table1.xxx=table2.xxx AND xxx AND xxx="";
等价于
SELECT col1 FROM　ｔａｂｌｅ１　ＷＨＥＲＥ　xxx IN(SELECT xxx FROM table2 WHERE xxx)

外部联结
就是包含没有关联的行，比如列出所有客户及订单，包括没有订单的客户
SELECT customers.cust_id, orders.order_num
FROM customers LEFT OUTER　JOIN orders
ON customers.cust_id = orders.cust_id
左联结，指联结OUTER　JOIN左边的表，即以左边的表为基准，左边表的行会全部显示，即使该行在右边表里没有记录。右联结类似，以右边为准
结果：
cust_id order_num
1001    00001
1002    NULL
1003    00002
NULL也会显示，如果没有外部联结，用自然联结，就会忽略NULL，因为没有订单

注：表左为集合A，表右为集合B，交集为C，则内联结为C，左联结为A+C，右联结为B+C

带函数的联结（函数可以用在任何地方，它和列有类似的效果，都可以写在SELECT后面）
SELECT customers.cust_name,
	customers.cust_id,
	COUNT(orders.order_num) AS num_ord
FROM customers INNER JOIN orders
ON customers.cust_id = order.cust_id
GROUP BY cutomers.cust_id;
在联结中需要注意的是标出表名

联结的条件：
注意联结类型，一般用内部联结，就是C（A，B交集）
保证正确使用联结，写出表名，太长的可以逐步调试
总是要给出联结条件，即WHERE　t1.x=t2.y
联结可以包含多个表


第十七章 组合查询
UNION创建组合查询
把前后两个SELECT粘和起来，把结果组成单个集合一起显示出来
价格小于等于5的商品，还有供应商为1001,1002的所有物品，可以用WHERE,但也可以用UNION
SELECT vend_id, prod_id, prod_price
FROM products
WHERE prod_price <= 5
UNION
SELECT vend_id, prod_id, prod_price
FROM products
WHERE vend_id IN (1001,1002);
结果：
vend_id prod_id prod_price
...
注意两个SELECT的列名相同
注：一般从多个表查询使用UNION更简单，单个表一般用WHERE

UNION规则
UNION必须由两个或以上个SELECT组成，之间必须用UNION，3条SELECT用2个UNION
UNION中的每个SELECT必须包含相同的列，表达式或函数，不过每个列的次序可以不同
列数据类型必须兼容，类型不必完全相同，但是MySQL可以自动转换就行

包含或取消重复行
UNION会自动去除重复的行，如果需要显示全部则用UNION ALL
SELECT vend_id, prod_id, prod_price
FROM products
WHERE prod_price <= 5
UNION ALL
SELECT vend_id, prod_id, prod_price
FROM products
WHERE vend_id IN (1001,1002);

对组合查询结果排序
如果用了UNION，则ORDER BY只能用一条，而且必须在最后一条SELECT之后
ORDER BY子句会对所有SELECT的结果分组，而不是仅对最后的那个SELECT（因为ORDER BY最后执行，查询结果已经合并成一个，所以会这样）
SELECT vend_id, prod_id, prod_price
FROM products
WHERE prod_price <= 5
UNION ALL
SELECT vend_id, prod_id, prod_price
FROM products
WHERE vend_id IN (1001,1002)
ORDER BY vend_id, prod_price;

注：UNION可以极大简化复杂的WHERE子句


第十八章 全文本搜索（应该是只支持英文）
使用全文本搜索时，MySQL不需要分别查看每行，MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行
必须索引被搜索的列才能用全文本搜索，而且要随着数据的改变不断重新索引，在对表进行适当设计后，MySQL会自动进行所有的索引和重新索引
索引后，SELECT可与Match()和Against()一起执行搜索

FULLTEXT全文本搜索
CREATE TABLE productnotes
(
	note_id	int NOT NULL AUTO_INCREMENT,
	prod_id char(10) NOT NULL,
	note_date datetime NOT NULL,
	note_text text NULL,
	PRIMARY KEY(note_id),
	FULLTEXT(note_text)
) ENGINE=MyISAM;
FULLTEXT(note_text)，对note_text列进行索引，之后Mysql会在增加，更新，删除行是自动更新索引
可以再创建表时索引，也可以稍后索引，不要再倒入数据时用FULLTEXT，最好在导入后再加，效率高些
一般用于大量的查询，比如字段是一片文章

SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('rabbit');
Match关键字对note_text列进行搜索，Against指定关机字rabbit
注：传给Match()的值必须与FULLTEXT()中定义的相同，如果指定多个列，则必须按次序列出；除非用BINARY模式，否则不区分大小写
可以用LIKE '%rabbit%'，但全文本搜索效率高，尤其是在文字很多时

布尔全文本搜索
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('rabbit -rope' IN BOOLEAN MODE);
查找包含rabbit但不包含rope开始的词的行，布尔模式允许各种条件，不包含，通配符等（这块比较偏，用时查）


第十九章 插入数据
可以对每个表或每个用户，通过MySQL配置禁用INSERT语句，后面会介绍

插入完整的行
INSERT INTO Customers
VALUES(NULL,
	'Jim',
	'14',
	'USA',
	NULL,
	NULL,);
这样写虽然简单，可是容易出现行对应不对的问题，比如Jim和14本来应该是14，Jim,写反了，易错，可以用下面的写法
INSERT INTO Customers（
	cust_name,
	cust_num,
	cust_country,
	cust_email,
	cust_contact
）VALUES(NULL,
	'Jim',
	'14',
	'USA',
	NULL,
	NULL,);
这种写法不容易出错，而且在列的顺序和表中顺序不一致时也不会出错
不管是哪种写法，都必须提供与列数相等的value个数
如果表允许省略列，则可以在insert时省略某列，但必须满足下面的某个条件： 该列允许为空或有默认值
大量客户访问时，INSERT操作因为很耗时而且会降低SELECT语句的性能，特别是有很多索引需要更新时，如果数据检索是优先级高的（一般情况是这样），则可以通过INSERT LOW_PRIORITY INTO降低INSERT的优先级，这个对UPDATE和DELETE都适用

插入多行
多条INSERT语句，每条语句用一个分号结束，或用下面的语句(性能比多条的写法高)
INSERT INTO customers(cust_name,
	cust_address,
	cust_state,
)
VALUES(
	'abc',
	'Main Street 1',
	'USA',
),
(
	'def'
	'Big Road 2'
	'England'
);

插入检索出的数据
INSERT INTO customers(cust_id,
	cust_address,
	cust_state)
SELECT id,
	address,
	state
FROM custtable;
注意，上下两个的列名不一定要一样，但数目一样


第二十章 更新和删除数据
UPDATE
用UPDATE时务必要注意WHERE，否则容易更新所有行，可以限制UPDATE语句的使用（权限，后面会介绍）
UPDATE三部分：要更新的表；列名和他们的新值；过滤条件
UPDATE customers
SET cust_email = 'elmer@fudd.com'
WHERE cust_id = 10001;

更新多个列，多个更新列之间用逗号隔开
UPDATE customers
SET cust_name = 'The Fudds',
	cust_email = 'elmer@fudd.com'
WHERE cust_id = 10001;
UPDATE中可以使用子查询，用SELECT检索出需要更新的列，比如WHERE cust_id IN (SELECT xxx FROM yyy WHERE zzz)
UPDATE更新多行时，如果这些行中出现错误，则整个UDPATE操作会被取消，回滚到原来的状态，如果需要即使发生错误也继续更新，则用UPDATE IGNORE...

如果要删除某个列的值，可以设置为NULL（表必须允许该列为NULL）
UPDATE customers
SET cust_email = NULL
WHERE cust_id = 10001;

删除数据
DELETE时需要注意WHERE，因为稍有不慎就会删掉所有行，DELETE也可以配置权限限制使用
DELETE FROM customers
WHERE cust_id = 10001;
DELETE不需要列名和通配符，因为它是针对行的，不是这对列，如果需要删除列，可以用UPDATE
注：DELETE仅用于删除行，但不可以删除表，如果需要删除表中所有行，可以使用TRUNCATE TABLE，删除原来表，并建一个新表

UPDATE和DELETE规则：
不要用不带WHERE的语句；
保证每个表都有主键，便于WHERE筛选；
使用前先用SELECT测试，看是不是想删或更新的行；
使用强制实施引用完整性的数据库，MySQL将不允许删除具有与其他表相关联的数据行

MySQL没有undo，如果删错或更新错就很麻烦了


第二十一章 创建和操纵表
创建表
CREATE TABLE必须给出的信息： 新表的名字，列的名字和定义（用逗号分隔）
CREATE TABLE customers
(
	cust_id  int   NOT NULL AUTO_INCREMENT,
	cust_name  char(50)  NOT NULL,
	cust_address char(50) NULL,
	cust_email  char(50)  NULL,
	PRIMARY KEY (cust_id)
) ENGINE=InnoDB;
注意主键的写法，还有创建表时的表明必须不存在，否则会出错，要防止意外覆盖已有的表，如果仅想在一个表不存在时创建它，则表名后给出IF NOT EXISTS

使用NULL值
允许NULL值得列也允许在插入行时不给出该列值，不允许NULL的列不接受该列没有值得行，即插入更新时必须有值
空串''是可以在NOT NULL的列插入的

主键
CREATE TABLE customers
(
	cust_id  int   NOT NULL AUTO_INCREMENT,
	cust_name  char(50)  NOT NULL,
	cust_address char(50) NULL,
	cust_email  char(50)  NULL,
	PRIMARY KEY (cust_id， cust_email)
) ENGINE=InnoDB;
多个列组成主键，任何时候，cust_id和cust_email的组合是唯一的
主键是唯一区别表中每个行的列，主键不允许NULL

AUTO_INCREMENT
自动增加，每次INSERT都会自动加一，每个表只允许一个AUTO_INCREMENT列，而且必须索引它，如把它定义为主键
INSERT时可以指定AUTO_INCREMENT的值（只要这个值是在表中没出现过的），后面的新插入行会以这个值为基准自动增加
可以用SELECT last_insert_id()查找最后一个AUTO_INCREMENT的列的值，last_insert_id()专门用于这个

指定默认值DEFAULT
CREATE TABLE orderitems
(
	order_num  int  NOT NULL,
	order_item  int  NOT NULL,
	prod_id  char(10)  NOT NULL,
	quantity  int  NOT　NULL DEFAULT 1,
	PRIMARY KEY (order_num, order_item)
) ENGINE=InnoDB;
Mysql不允许用函数做默认值，只允许常量
用默认值，而不是NULL列，特别对于需要COUNT，GROUP BY的列更是如此

引擎类型
省略ENGING=，则用默认引擎，各种请求都是由引擎处理，MySQL支持多种引擎
InnoDB，可靠地事务处理引擎，不支持全文本搜索
MEMORY在功能等同于MyISAM，但数据存在内存，速度快，适合建立临时表用
MyISAM，一个性能很高的引擎，支持全文本搜索，但不支持事物处理
引擎类型可以混用，不同表用不同引擎，但外键不能跨引擎

更新表
ALTER TABLE： 之后要给出表名，所做更改的列
ALTER TABLE vendors
ADD vend_phone CHAR(20);

ALTER TABLE vendors
DROP COLUMN vend_phone;

ALTER TABLE的一个常见用途是定义外键
约束
1.主键约束：
格式为：
alter table 表格名称 add constraint 约束名称 增加的约束类型 （列名）
例子：
alter table emp add constraint ppp primary key (id);

2.check约束：就是给一列的数据进行了限制
格式：
alter table 表名称 add constraint 约束名称 增加的约束类型 （列名）
例子：
alter table emp add constraint xxx check(age>20);

3.unique约束：这样的约束就是给列的数据追加的不重复的约束类型
格式：
alter table 表名 add constraint 约束名称 约束类型（列名）
例子：
alter table emp add constraint qwe unique(ename);

外键约束：
格式：
alter table 表名 add constraint 约束名称 约束类型 (列名) references 被引用的表名称 （列名）
例子：
alter table emp add constraint jfkdsj foreign key (did) references dept (id);

ALTER TABLE orderitems
ADD CONSTRAINT fk_orderitems_orders
FOREIGN KEY (order_num) REFERENCES orders (order_num);
注：更改表要小心，最好先备份一个，数据库更改不能撤销

删除表
DROP TABLE customers2;

重命名表
RENAME TABLE customers2 TO customers;
RENAME TABLE t1 TO table1,
			t2 TO table2,
			t3 TO table3;

注： ALTER可以更改多个，只要以逗号隔开就行


第二十二章 使用视图
视图是虚拟的表，视图只包含使用时动态检索数据的查询
SELECT cust_name, cust_contact
FROM customers, orders, orderitems
WHERE customers.cut_id = order.cust_id
	AND orderitems.order_num = orders.order_num
	AND prod_id = 'TNT2';
把查询做成一个叫pc的虚拟表（pc是一个视图，它只是一个SQL查询），则可以
SELECT cust_name, cust_contact
FROM pc
WHERE prod_id = 'TNT2';

为什么用视图
重用SQL语句；简化复杂的SQL操作；使用表的部分而不是整个表；保护数据（授予表特定部分的权限，而不是整个表的访问权限）；更改数据名字格式，视图可返回与底层不同名字格式的数据
视图创建后，和表的用法基本一样
视图本身不包含数据，它们返回的数据是从表中检索出来的，如果添加或改变这些表中的数据，则视图将返回改变过的数据；因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的所有SELECT，如果用了复杂的联结创建视图或嵌套视图会导致性能下降

视图的规则：
视图必须唯一命名，不能与其他视图和表名一样
可以创建的视图数目没有限制
足够的访问权限
视图可以嵌套，可以用从其他视图中SELECT出来的数据来构造一个视图
ORDER BY可以用在视图中，不过如果从视图检索数据SELECT语句也有ORDER BY，则会覆盖视图的ORDER BY
视图不能索引，也不能有关联的触发器或默认值
视图可以与表一起使用，SELECT xx, yy ROM table1， view;

使用视图
CREATE VIEW创建视图；
SHOW CREATE VIEW viewname查看创建视图
DROP VIEW 删除视图
更新视图可以先DROP在CREATE，也可以CREATE OR REPLACE VIEW，这个语句会检查，如果不存在则新建，如果存在，则替换

利用视图简化复杂的联结
视图最常见的应用是隐藏复杂的SQL，而复杂的SQL一般都包括联结
CREATE VIEW productcustomers AS
SELECT cust_name, cust_contact, prod_id
FROM customers, orders, orderitems
WHERE custoemrs.cust_id = orders.cust_id
	AND orderitems.order_num = orders.order_num;
视图productcustomers联结了三个表，执行SELECT * FROM productcustomers WHERE prod_id = 'TNT2';更简单清晰
视图可以简化SQL，而且可以对复杂的SQL一次编写，多次使用
注：创建不受特定数据限制的视图是一种好办法，如上面创建的是所有产品的而不是TNT2的，这样可重用的范围更大，不需要维护太多视图

用视图重新格式化检索出的数据
如果经常需要使用某个格式，则可以这么写：
CREATE VIEW vendorlocaitons AS
SELECT Contact(RTrim(vend_name), '(', RTrim(vend_country), ')')
	AS vend_title
FROM vendors
ORDER BY vend_name;
之后就可以用: SELECT * FROM vendorlocaitons；

用视图过滤不想要的数据
视图对于普通WHERE也很有用，比如需要选出email不是NULL的
CREATE VIEW customeremail AS
SELECT cust_id, cust_name, cust_email
FROM customers
WHERE cust_email IS NOT NULL;
就像使用表一样使用视图：SELECT * FROM customeremail;

视图与计算字段
CREATE VIEW orderitemsexpanded AS
SELECT prod_id,
	quantity,
	item_price,
	quantity*item_price AS expanded_price
FROM orderitems;
之后：SELECT * FROM orderitemsexpanded WHERE order_num = '10001';
注：视图往往都是SELECT *，具体列在视图内部选出，外部只用WHERE,不过SELECT具体列也是可以的

更新视图
一般情况下，视图是可更新的，对视图可用INSERT，UPDATE，DELETE，更新一个视图将更新至表，如果对视图删除增加其实是对表操作
但并非所有视图都是可更新的，如果MySQL不能确定更新的表中原始数据，则不允许更新，即如果视图中有以下操作，则不能更新视图：
分组，GROUP BY或HAVING；联结；子查询；并；聚集函数（Min，Count，Sum等）；DISTINCT；计算列（不怎么用记，反正视图不用于修改，同时不要轻易改视图）
其实这并不太限制使用，因为视图用于数据检索，而不用于数据更新
一般应该把视图用于检索（SELECT）而不是更新（INSERT，UPDATE，DELETE）


第二十三章 使用存储过程
存储过程就是为以后使用而保存的一条或多条MySQl语句的集合，类似于批处理
存储过程简单（封装后更易用），安全（减少处理错误的概率），性能高（比单独SQL要快，估计是MySQL对存储过程做过优化）

MySQL执行存储过程的语句：CALL，其后需要有存储过程名字和参数，类似于函数
CALL productpricing(@pricelow,
					@pricehigh,
					@priceaverage);

创建存储过程
注意：MySQL默认分隔符是;但是存储过程里需要;就和函数一样，会出错，必须这么写：
DELIMITER //

CREATE PROCEDURE productpricing()
BEGING
	SELECT Avg(prod_price) AS priceaverage
	FROM products;
END //

DELIMITER ;
DELIMITER修改默认分隔符，可以修改成任何字符，这里用的是//，END最后//表示结束，然后再改到;
调用存储过程: CALL productpricing()

删除存储过程
DROP PROCEDURE productpricing()
DROP PROCEDURE IF EXISTS productpricing()

参数（注意写法）
CREATE PROCEDURE productpricing(
	OUT pl DECIMAL(8,2),
	OUT ph DECIMAL(8,2),
	OUT pa DECIMAL(8,2)
)
BEGING
	SELECT Min(prod_price)
	INTO pl
	FROM products;
	SELECT Max(prod_price)
	INTO ph
	FROM products;
	SELECT Avg(prod_price)
	INTO pa
	FROM products;
END;
注意参数紧跟类型，前面参数类型的OUT是从存储过程传出（存储过程执行后，SELECT语句可直接用），IN是外面传给存储过程，INOUT是对存储过程传入传出（一般用于存储过程内，SELECT之后存到OUT的参数时），MySQL支持这三种参数类型
注意没有大括号，由BEGING开始，END结束
存储过程允许的参数类型和表中使用的一样，但记录集不允许，不可以用一个参数返回多个行或列，这就是这个例子用三个参数的原因
CALL productpricing(@pricelow,
					@pricehigh,
					@priceaverage);
执行后，不会显示任何东西，但这时可以用了
SELECT @priceaverage;
SELECT @pricelow,@pricehigh;
注意：MySQL中的变量都以@开头

IN和OUT参数
CREATE PROCEDURE ordertotal(
	IN onumber INT,
	OUT ototal DECIMAL(8,2)
)
BEGING
	SELECT Sum(item_price*quantity)
	FROM orderitems
	WHERE order_num = onumber
	INTO ototal;
END;
--第一个为订单号，第二个为返回结果
CALL ordertotal(10001, @total); 
SELECT @total;

智能存储过程（重要的例子，重点看）
需要对某些顾客增加营业税：获得结果；把营业税根据条件添加到结果；返回结果
存储过程如下：
-- Name: ordertotal
-- Parameters: onumber = order number
-- 				taxable = 0 if not taxalbe, 1 if taxable
--				ototal = order total variable

CREATE PROCEDURE ordertotal(
	IN onumber INT,
	IN taxable BOOLEAN,
	OUT ototal DECIMAL(8,2)
) COMMENT 'Obtain order total, optionally adding tax'
BEGING

	-- Declare varibale for total
	DECLARE total DECIMAL(8,2);
	-- Declare tax percentage
	DECLARE taxrate INT DEFAULT 6;

	-- Get the order total
	SELECT Sum(item_price*quantity)
	FROM orderitems
	WHERE order_num = onumber
	INTO total;

	IF taxable THEN
		SELECT total+(total/100*taxrate) INTO total;
	END IF;

	-- And finally, save to out varialbe
	SELECT total INTO ototal;

END;
CALL ordertotal(10001, 0, @total);
SELECT @total;

注释是--，
DECLARE声明变量，声明出的变量和列一样可以SELECT等操作，
COMMENT（非必须）关键字用于对存储过程说明，会在SHOW PROCEDURE STATUS中显示，
BOOLEAN值，0,1表示，并非true/false
IF THEN END IF关键字，
存储过程里的赋值，全部用SELECT 原变量或处理后的原变量 INTO 目的变量，注意存储过程没有返回值，OUT类似返回值

SHOW CREATE PROCEDURE ordertotal;
显示创建一个存储过程的CREATE语句
为获取谁创建，何时创建等详细信息用SHOW PROCEDURE STATUS，列出所有的，可用SHOW PROCEDURE STATUS LIKE 'ordertotal'过滤


第二十四章 使用游标
cursor，游标，是一个存在MySQl服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集，在存储了游标之后就可以根据需要取数据了，比如得到第一行，前10行等
MySQL的游标只能用于存储过程

游标使用规则：使用前必须声明；声明后必须打开；结束关闭游标

创建游标()
CREATE PROCEDURE processorders()
BEGING
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
END;
创建游标需要DECLARE cursorname CURSOR FOR SELECT 

打开和关闭游标
OPEN ordernumbers;
CLOSE ordernumbers;
END时会自动关闭游标，即使如此还是要显示调用为好

游标数据
FETCH关键字，FETCH cursorname INTO variable
CREATE PROCEDURE processorders()
BEGING
	DECLARE o INT;

	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;

	OPEN ordernumbers;

	FETCH ordernumbers INTO o;

	CLOSE ordernumbers;
END;

循环检索至最后一行
CREATE PROCEDURE processorders()
BEGING
	DECLARE o INT;

	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;

	--设置done为真的条件是，SQLSTATE 02000（未找到条件错误），即没有更多的行
	DECLARE CONTIUE HANDLER　FOR SQLSTATE '02000' SET done=1;

	OPEN ordernumbers;

	REPEAT
		FETCH ordernumbers INTO o;
	UNITL done END REPEAT;

	CLOSE ordernumbers;
END;
CONTIUE HANDLER是条件出现时被执行的代码，记住这么写就行，另外注意REPEAT UNTIL，END REPEAT语句
DECLARE语句有顺序，局部变量必须声明在游标之前，而游标又必须在句柄之前

实践
CREATE PROCEDURE processorders()
BEGING
	-- Declare local variables
	DECLARE done BOOLEAN DEFAULT 0;
	DECLARE o INT;
	DECLARE t DECIMAL(8,2);

	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;

	-- Decalre continue handler
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;

	-- Create a table to store the result
	CREATE TABLE IF NOT EXISTS ordertotals
		(order_num INT, total DECIMAL(8,2));

	-- Open the cursor
	OPEN ordernumbers;

	-- Loop
	REPEAT

		-- Get the data and store it to variable
		FETCH ordernumbers INTO o;

		-- Get the total through procedure
		CALL ordertotal(o, 1, t);

		INSERT INTO ordertotals(order_num, total)
		VALUES(o, t);

	UNTIL done END REPEAT;

	CLOSE ordernumbers

END;
使用存储过程中新建的表
SELECT * FROM ordertotals；


第二十五章 使用触发器
触发器就是在DELETE，INSERT，UPDATE操作执行前后执行的操作，类似AOP（MySQL只支持这三个语句的触发器）

创建触发器（CREATE TRIGGER）
4个信息：
唯一的触发器名（MySQL允许库中不唯一，表中唯一，但最好还是数据库范围内唯一）
触发器关联的表
触发器响应的活动，包括DELETE，INSERT，UPDATE
执行时间，BEFORE或AFTER

CREATE TRIGGER newproduct AFTER INSERT ON products
FOR EACH ROW SELECT 'product added'；
创建名为newproduct的触发器，在INSERT后执行，指定FOR EACH ROW，对每个插入都会显示product added

如果BEFORE触发器失败，则MySQL不执行请求，如果BEFORE触发器失败，则MySQL也不会执行AFTER触发器

删除触发器(触发器不能更新，只能先删除再新建)
DROP TRIGGER newproduct;

INSERT触发器
在INSERT语句之前或之后，有几点需要注意：
INSERT触发器带埋内，可引用一个名为NEW的虚拟表，访问被插入行（这个表由MySQl提供，不用创建和管理）；
在BEFORE INSERT触发器中，NEW表的值可以被更新，允许更新被插入的值，在NEW表中更新后插入真正的表中；
对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值
例：
CREATE TRIGGER neworder AFTER INSERT ON orders
FOR EACH ROW SELECT NEW.order_num;
每次插入后返回新的订单号，因为在之前还没有生成
这时如果插入一行，则会显示订单号，由NEW表中查询到的
INSERT INTO orders(order_date, cust_id)
VALUES(Now(), 10001);
结果：
order_num
200010
订单号自动生成，可返回查看
注：一般BEFORE用于数据验证，保证插入数据合法，UPDATE也适用，因为如果数据不合法，BEFORE触发器失败，则插入不会执行

DELETE触发器
DELETE触发器可以医用一个名为OLD的虚拟表，访问被删除的行；
OLD中的值都是只读的
例：
CREATE TRIGGER deleteorder BEFORE DELETE ON orders
FOR EACH ROW
BEGING
	INSERT INTO archive_orders(order_num, order_date, cust_id)
	VALUES(OLD.order_num, OLD,order_date, OLD.cust_id);
END;
删除订单前执行此触发器，触发器用INSERT把OLD中，即要删除的订单，保存到一个表中
这种触发器的有的是由于某种原因订单不能存档，DELETE不会执行，BEGING END可以不用，但用了没坏处，可以写多行

UPDATE触发器
可以引用OLD虚拟表访问UPDATE之前的值，还可以引用NEW虚拟表访问新的值；
在BEFORE UPDATE触发器中，NEW中的值可能被更新
OLD中的值只读
例：保证州名都是大写，不管UPDATE给出的是大写还是小写
CREATE TRIGGER updateevendor BEFORE UPDATE on vendors
FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);
NEW表的值更新后再插入数据库中的表里，NEW表可以理解为一个插入前的缓存，在这个缓存里改数据可以直接生效


第二十六章 管理事务处理
InnoDB支持管理事务，MyISAM不支持，这点要注意
事务处理(transaction processing)，用于维护数据库完整性，保证成批的MySQL操作要么完全执行，要么全部不执行
比如生成订单需要好几个步骤，其中一步出错可能生成不完整订单，这时就需要事务管理，要么生成完整订单，要么不生成

事务的术语：
事务(transaction)，一组SQL语句；
回退(rollback)，撤销指定SQL语句
提交(commit),未存储的SQL语句结果写入数据库
保留点(savepoint)，临时占位符，可以发布回退

事务处理
-- 表示事务开始
START TRANSACTION

-- ROLLBACK
SELECT * FROM ordertotals;
START TRANSACTION;
DELETE FROM ordertotoals;
SELECT * FROM ordertotoals;
ROLLBACK;
SELECT * FROM ordertotoals;
首先start事务，再把ordertotoals表的所有行删除，然后检查是不是所有行都删除了，之后rollback，最后检查rollback结果
ROLLBACK只能回退INSERT，UPDATE，DELETE，不能回退DROP和CREATE

-- COMMIT
一般SQL语句会默认commit，隐含提交，但是事务中不会，必须调用COMMIT才会提交到server执行
START TRANSACTION;
DELETE FROM ordertotoals WHERE order_num = 1000；
DELETE FROM ordertotoals WHERE order_num = 2000；
COMMIT；
注：COMMIT和ROLLBACK执行后，事务会自动关闭

-- 保留点
部分提交或回退，必须在事务处理中布置占位符，如果需要回退则可以退到某占位符，占位符的名字必须唯一
创建占位符：SAVEPOINT
SELECT * FROM ordertotals;
START TRANSACTION;
DELETE FROM ordertotoals WHERE order_num = 1000；
SAVEPOINT delete1；
DELETE FROM ordertotoals WHERE order_num = 2000；
SELECT * FROM ordertotoals;
ROLLBACK TO delete1;
SELECT * FROM ordertotoals;
注：保留点（就是占位符）会在事务处理完后自动释放，也可用RELEASE SAVEPOINT释放

可以用SET autocommit=0;禁止自动提交


第二十七章 本地化
字符集和校对顺序
字符集：字母和符号的集合
编码：字符集成员的内部表示
校对：字符如何比较的指令(是否区分大小写之类)

--查看可用字符集
SHOW CHARACOTER SET；

--查看校对
SHOW COLLATION;

-- 查找所用字符集和校对
SHOW VARAIBLES LILE 'character%';
SHOW VARIABLES LIKE 'collation%';

字符集很少是服务器范围，不同的表，不同的列都可能有不同的字符集，在创建表时可以指定
CREATE TABLE mytalbe
(
	column1 INT,
	column2 VARCHAR(8)
) DEFAULT CHARACTER SET hebrew
  COLLATE hebrew_general_ci;
如果指定CHARACTER SET和COLLATE则用指定的，如果仅指定CHARACTER SET则用该字符集默认的校对，如果两个都没指定则用数据默认的
注：最多指定字符集，校对用默认的就行，一般不怎么用特殊的校对

-- 为每个列设置字符集
CREATE TABLE mytalbe
(
	column1 INT,
	column2 VARCHAR(8)，
	column3 VARCHAR(8) CHARACTER SET latin COLLATE lantin_general_ci
) DEFAULT CHARACTER SET hebrew
  COLLATE hebrew_general_ci;
列column3用拉丁，其他默认

还可以对列临时规定校验
SELECT * FROM customers
ORDER BY lastname, firstname COLLATE latin_general_cs;
对firstname临时规定校验，区分大小写


第二十八章 安全管理
管理用户
USE mysql;
SELECT user FROM user;
mysql有默认表user，存着所有账号

-- 创建用户账号
CREATE UEER ben INDENTIFIED BY 'p@$$v0rd';
新建用户ben，密码为p@$$v0rd
GRANT可以创建新用户，但是一般CREATE USER最清楚，还可以直接INSERT用户到user表，但一般不这么做

-- 重命名用户
RENAME USER ben to bforta;

-- 删除用户
DROP USER bforta；

设置访问权限
-- 显示用户权限
SHOW GRANTS FOR bforta;

--设置用户权限
需要以下信息：
要授予的权限，比如SELECT，DELETE，UPDATE，EXEUCTE（存储过程）等；
访问的数据库或表；
用户名
GRANT SELECT ON crashcourse.* TO bforta;
授予bforta用户在crashcourse.*(该数据库的所有表)用SELECT的权限（仅有访问权限）

-- REVOKE撤销权限
REVOKE SELECT ON crashcourse.*  FROM bforta;

GRANT REVOKE层次：
整个服务器，用GRANT ALL 和 REVOKE ALL；
整个数据库， ON database.*；
表， ON database.table；
特定列；
特定存储过程
（具体权限可以查询，很多，不用都记住）
GRANT和INVOKE用户必须存在，但数据库和表不用，可以创建数据库和表之前规定好权限，但这样做会有副作用，当数据库或表被删除时（DROP）相关的访问权限还在，而且如果重新创建该表或数据库，则之前的权限依然起作用
可以逗号分隔把多条GRANT合并：GRANT SELECT，INSERT ON crashcourse* TO bforta;

重设其他用于的密码：SET PASSWORD FOR bforta = Password('newpasswd');
还可以重设自己的密码：SET PASSWORD = Password('newpasswd');


第二十九章 数据库维护
备份数据
mysqldump命令吧数据内容存到某个外部文件
mysqlhotcopy命令从一个数据库赋值全部数据，有的引擎不支持
BACKUP TABLE或SELECT INTO OUTFILE转存到外部文件
注： 在备份前可能要用FLUSH TABLES命令可以保证所有数据被写出，包括索引

数据库维护
ANALYZE TABLE检查表键是否正确
CHECK TABLE检查表状态

诊断
mysql --help 帮助
mysql --version 版本
mysql --verbose显示全文本信息

查看日志
错误日志，名为hostname.err，位于data目录， --log-error选项查询
普通日志，名为hostname.log，位于data目录， --log选项查询
二进制日志，名为hostname-bin，；位于data目录，--log-bin
缓慢日志，包含执行缓慢的查询，hostname-slow.log,位于data目录，--log-slow-queries


第三十章 改善性能
总有不止一种方法编写SQL语句，实验联结，并，子查询，看哪个好一些
一般存储过程比SQL执行快
使用正确的数据类型
不要检索不需要的列，少用SELECT *
导入数据时，关闭自动提交，导入后再打开，还有删除索引，导入后再重建
用UNION代替OR
索引改善查询性能，但损害插入删除更新的性能，根据表的需要设置索引
LIKE很慢，一般用FULLTEXT而不是LIKE


增加章节： 索引（这本书没有索引的章节）
执行下面的SQL语句：
1
mysql> SELECT id,FROM_UNIXTIME(time) FROM article WHERE a.title='测试标题'
查询需要的时间非常恐怖的，如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。这时给title字段添加一个BTREE索引：
1
mysql> ALTER TABLE article ADD INDEX index_article_title ON title(200);
再次执行上述查询语句，其对比非常明显：

MySQL索引的概念
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。上述SQL语句，在没有索引的情况下，数据库会遍历全部200条数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。（注：一般数据库默认都会为主键生成索引）。
索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。
MySQL索引的类型
1. 普通索引
这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。

–直接创建索引
CREATE INDEX index_name ON table(column(length))

–修改表结构的方式添加索引
ALTER TABLE table_name ADD INDEX index_name ON (column(length))

–创建表的时候同时创建索引
CREATE TABLE `table` (
`id` int(11) NOT NULL AUTO_INCREMENT ,
`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
`time` int(10) NULL DEFAULT NULL ,
PRIMARY KEY (`id`),
INDEX index_name (title(length))
)

–删除索引
DROP INDEX index_name ON table

2. 唯一索引
与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。

–创建唯一索引
CREATE UNIQUE INDEX indexName ON table(column(length))
–修改表结构
ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))
–创建表的时候直接指定
CREATE TABLE `table` (
`id` int(11) NOT NULL AUTO_INCREMENT ,
`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
`time` int(10) NULL DEFAULT NULL ,
PRIMARY KEY (`id`),
UNIQUE indexName (title(length))
);

3. 全文索引（FULLTEXT）
MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

–创建表的适合添加全文索引
CREATE TABLE `table` (
`id` int(11) NOT NULL AUTO_INCREMENT ,
`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
`time` int(10) NULL DEFAULT NULL ,
PRIMARY KEY (`id`),
FULLTEXT (content)
);

–修改表结构添加全文索引
ALTER TABLE article ADD FULLTEXT index_content(content)

–直接创建索引
CREATE FULLTEXT INDEX index_content ON article(content)

4. 单列索引、多列索引
多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。

5. 组合索引（最左前缀）
平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：
–title,time
–title
为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：
–使用到上面的索引
SELECT * FROM article WHREE title='测试' AND time=1234567890;
SELECT * FROM article WHREE utitle='测试';

–不使用上面的索引
SELECT * FROM article WHREE time=1234567890;

MySQL索引的优化
上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。

索引不会包含有NULL值的列
只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

使用短索引
对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

索引列排序
MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

like语句操作
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引,最左匹配。

不要在列上进行运算
例如：select * from users where YEAR(adddate)<2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate<’2007-01-01′

最后总结一下，MySQL只对一下操作符才使用索引：<,<=,=,>,>=,between,in,以及某些时候的like(不以通配符%或_开头的情形)。而理论上每张表里面最多可创建16个索引，实际中，一般不要创建过多索引


---------------------------------------------The END----------------------------------------------