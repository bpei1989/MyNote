第一章 Spring之旅
1.简化Java开发
为降低Java开发复杂性，Spring采取了以下几种关键策略：
基于POJO的轻量级和最小入侵性编程；
通过依赖注入和面向接口编程实现松耦合；
基于切面和惯例进行声明式编程；
通过切面和模板减少样式代码。

(1)POJO
单纯的Java类，不需要继承什么，这样就不会有什么限制，灵活，解耦

(2)依赖注入
骑士只能执行探险任务
package com.springinaction.knights;
public class DameslRecusingKnight implements Knight {
	private RecueDaselQuest quest; //注意这里不是接口
	public DamselRecusingKnight() {
		quest = new RescueDameslQuest();//紧耦合
	}
	public void embarkOnQuest() throws QuestException {
		quest.embark();
	}
}
这个类只能执行RescueDamesl任务，其他的任务不能执行

面向接口的依赖注入（如果没有接口，而是一个具体类，则依赖注入就没有意义了，因为那样只能注入一种类）
package com.springinaction.knights;
public class BraveKnight implements Knight {
	private Quest quest;
	public BraveKnight(Quest quest) {
		this.quest = quest; //注入
	}
	public void embarkOnQuest() throws QuestException {
		quest.embark();
	}
}
BraveKnight没有自己创建探险任务，而是在构造时把探险任务作为构造器参数传进来，这就是依赖注入的方式之一，构造器注入
还有传入类型是Quest，所以实现这个接口的所有类都可以执行，这就是依赖注入的好处，松耦合。如果一个对象只通过接口来表明依赖关系，而不是具体类，就能用不同具体实现类进行替换
测试也很容易
public class BraveKnightTest implements Knight {
	Quest mockQuest = mock(Quest.class);//mockito
	BraveKnight knight = new BraveKinght(mockQuest);//注入mock
	knight.embarkOnQuest();
	verify(...);
}

创建组件之间的协作称为装配。Spring有多种装配Bean方式，用XML配置最常用
分配给骑士一个SlayDragon任务
<beans
...>
	<bean id="knight" class="com.springinaction.knights.BraveKnight">
		<!--注入-->
		<constructor-arg ref="quest" />
	</bean>
	<bean id="quest" 
		class="com.springinaction.knights.SlayDragonQuest" />
</beans>
Spring通过ApplicationContext装载Bean的定义，并组装它们。一般用ClassPathXMLApplicationContext加载classpath中的一个或多个xml
public class KnightMain {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("knights.xml");//加载上下文
		Knight knight = (Knight)context.getBean("knight");
		kinght.embarkOnQuest();
	}
}
这个类完全不知道接受哪种任务，没有意识到时由谁来执行，这些都是在knights.xml中定义，这就是依赖注入，或控制反转

(3)切面
依赖注入让相互协作的组件保持松耦合，AOP允许把通用的模块分离出来形成可重用组件
吟游诗人记录了骑士的事迹
public class Ministrel {
	public void singBeforeQuest() {
		System.out.println("The knight is brave!");
	}
	public void singAfterQuest() {
		System.out.println("The knight finished the quest");
	}
}
调用，如果在骑士类中加一个吟游诗人类成员变量则不合适，因为骑士不负责吟诗，骑士类复杂化，正确做法：
Ministrel抽象成一个切面，在配置中声明
<beans ...
	在beans里配置aop的schema..>
	<bean id="knight" class=class="com.springinaction.knights.BraveKnight">
		<constructor-arg ref="quest" />
	</bean>
	<bean id="quest" 
		class="com.springinaction.knights.SlayDragonQuest" />
	<bean id="minstrel"
		class="com.springinaction.knights.Minstrel" />
	<aop:config>
		<aop:aspect ref="minstrel">
			<aop:pointcut id="embark"
				expression="execution(* *.embarkOnQuest(..))"/> 切面
			<aop:before pointcut-ref="embark"
						method="singBeforeQuest" /> 前置声明
			<aop:after pointcut-ref="embark"
						method="singAfterQuest"/> 后置
		</aop:aspect>
	</aop:config>
</beans>
Minstrel是POJO，没有任何代码表示她要作为一个切面，其次，也是最重要的，Minstrel可以应用到BraveKnight中，而BraveKnight不需要显式调用它，实际上BraveKnight完全不知道Minstrel的存在

(4)使用模板消除样式代码
JDBC有很多与逻辑不相关的代码，用来处理异常等，可以用Spring提供的SimpleJdbcTemplate来简化，了解，因为有ibatis，所以不太会用jdbctemplate


2.Bean
Spring提供了多种容器，有BeanFactory和ApplicationContext，ApplicationContext基于BeanFactory，增加了面向应用的服务，如发布应用事件给事件监听者，一般都会用ApplicationContext
(1)应用上下文
Spring有好几种ApplicationContext，以下三种是经常遇到的
ClassPathXMLApplicationContext，从classpath环境变量里的xml中加载上下文定义
FileSystemXmlapplicationcontext,读取文件路径下的xml配置并加载上下文定义
XmlWebApplicationContext，读取Web应用下的XML配置并加载上下文定义
用法： 
ApplicationContext ctx = new ClassPathXMLApplicationContext（"knight.xml"）；
Knight knight = (Knight)context.getBean("knight");

(2)Bean生命周期
基本流程：实例化-填充属性-加载入上下文-bean可以使用了-容器关闭-销毁bean


3.Spring整体架构
Spring框架由如下模块组成
(1)核心Spring容器：负责bean创建，配置和管理等，其中Bean Factory提供了依赖注入
(2)AOP模块：面向切面编程模块
(3)数据访问与集成：JdbcTemplate和对ORM框架的集成，如iBATIS
(4)Web和远程调用：集成MVC，Spring MVC和远程调用
(5)测试：集成测试模块来测试Spring应用


Spring portfolio（portfolio 作品集）
Spring Web Flow:基于Spring MVC并未基于流程的Web应用，比如购物车，提供支持
Spring Web Service:将Bean以声明的方式发布为Web Service
Spring Security：安全是一个重要的切面，基于Spring AOP，Spring Security提供了声明式的机制
Spring Integraion：几种通用的应用集成模式，主要用于与其他应用交互
Spring Batch：适用于对数据进行大量操作，批处理应用
Spring Dynamic Modules:整合Spring的声明式依赖注入和OSGi的动态组件模型，Spring-DM可以采用模块化的方式构建应用，并在OSGi框架内以声明的方式发布和使用服务
Spring LDAP：模板方式访问LDAP
Spring Social，Spring Mobie，Spring Rich Client，Spring.Net,Spring Roo,Spring-Flex可以不看



第二章 装配Bean
1.声明bean
Spring常用命名空间：
aop,benas,context,jms，mvc，tx（事务）

例子：才艺大赛
参赛者接口
package com.springaction.springidol;
public interface Performer {
	void perform() throws PerformanceException;
}

第一位参赛者,名字：Duke，职业：杂技师：
package com.springaction.springidol;
public class Juggler implements Performer {
	private int beanBags = 3;
	public Junggler() {}
	public Junggler(int beanBags) {
		this.beanBags = beanBags;
	}
	public perform() throws PerformanceException {
		System.out.println("JUGGLING " + beanBags + " BEANBAGS");
	}
}
在Spring配置文件中声明
spring-idol.xml
<bean id="duke" class="com.springaction.springidol.Juggler" />
当Spring容器加载Bean时，Spring江永默认构造器来实例化duke Bean
为了给Duke一个表演的环境，需要加载一个Spring上下文,之后让duke表演
ApplicationContext ctx = new ClassPathXmlApplicationContext("com/springaction/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("duke");
performer.perform();
结果：JUGGING 3 BEANBAGS

评委觉得3个袋子不够，duke决定抛15个袋子，下面使用xml把Duke声明为一个可以同时抛15个袋子的杂技师：
<bean id="duke" 
	class="com.springaction.springidol.Juggler">
	<constructor-arg value="15" />
</bean>
Duke表演时：JUGGING 15 BEANBAGS
(构造器注入，通过constructor-arg声明入参)

Duke其实还会朗诵诗歌，如果一边表演杂技一边朗诵诗歌，则获得冠军的可能性就很打
这时Duke其实就不仅仅是Junggler了，他是PoeticJuggler
package com.springaction.springidol;
public class PoeticJuggler extends Juggler {
	private Poem poem; //Poem引用

	public PoeticJuggler(Poem poem) {//注入
		super();//初始化Juggler，使其拥有杂技师技能
		this.poem = poem;//Poem引用，使其可以朗诵诗歌
	}

	public PoeticJuggler(int beanBags, Poem poem) {
		super(beanBags);//初始化Juggler，使其拥有15个袋子杂技师技能
		this.poem = poem;//Poem引用，使其可以朗诵诗歌
	}

	public perform() throws PerformanceException {
		super.perform();//杂技师表演
		System.out.println("While reciting ");
		poem.recite();
	}

}

由于需要朗诵诗歌，所以需要定义Poem接口
package com.springaction.springidol;
public interface Poem {
	void recite();
}
Poem类和bean
public class Sonnet29 implements Poem {
	private static String[] LINES = {"xxx","yyy"};
	public Sonnet29() {}
	public void recite() {
		for (int i=0; i<LINES.length; i++) {
			System.out.println(LINE[i]);
		}
	}
}
<bean id="sonnet29" 
	class="com.sringaction.springidol.Sonnet29" />

把poem赋予Duke
<bean id="poeticDuke" class="com.sringaction.springidol.PoeticJuggler">
	<constructor-arg value="15" />
	<constructor-arg ref="sonnet29" />
这样Duke就可以一边表演杂技，一边朗诵诗歌了

factory-method属性
大赛只有一个舞台，而舞台上只允许一个人表演，单例类
package com.springaction.springidol;
public class Stage {
	private Stage() {}
	private static class StageSingletonHolder {
		static Stage instance = new Stage();//延迟加载
	}
	public static Stage getInstance() {
		return StageSingleonHolder.instance;
	}
}
没有public的构造函数，用factory-method声明bean
<bean id="theStage" 
	class="com.springaction.spingidol.Stage" factory-method="getInstance" />

Bean作用域
所有Spring Bean默认都是单例，即每次getBean都返回同一实例。有时需要覆盖这种行为
（注：所有scope都是基于Application Context的，一般默认的就行）
观看演出每个人必须收到不同的票，而不是同一张，所以需要把scope属性设置为prototype保证获取不同实例
Spring支持的Bean作用域（scope='xxx'）：
singleton:每一个Spring容器中，一个Bean定义只有一个实例（默认）
prototype:每次调用都创建一个实例
request:一次HTTP请签字，每个Bean对应一个实例，该作用域仅在基于web，如Spring MVC，中才有效
session：一个HTTP Session中，每个Bean对应一个实例，该作用域仅在基于web，如Spring MVC，中才有效
global-session:一个全局HTTP Session中，每个Bean对应一个实例，仅在Portlet上下文中有限

初始化和销毁Bean
init-method和destroy-method指定初始化和销毁Bean时执行的操作（针对Bean的）
Auditorium为表演大厅类，表演开始前要开灯， 结束后要关灯
public class Auditorium {
	public void turnOnLights() {
		...
	}
	public void turnOffLights() {
		...
	}
}
<bean id="auditorium" 
	class="turnOffLights.Auditorium"
	init-method="turnOnLights"
	destory-method="turnOffLights" />
Bean实例化后会调用turnOnLights，Bean从容器中销毁前，会调用turnOffLights
default-init-method,default-destory-method，全局所有bean有效
<beans xmlns
	...
	default-init-method="turnOnLights"
	default-destory-method="turnOffLights"
</beans>


2.注入Bean属性
通过set和get方法，以setter和getter方式注入
Kenny是一个乐器演奏家
package com.springaction.spingidol;
public interface Instrument {
	public void play();
}

package com.springaction.spingidol;
public class Instrumentalist implements Performer {
	public Instrumentalist() {}
	public perform() throws PerformanceException {
		System.out.println("Playing " + song + ":");
		instrument.play();
	}
	private String song;
	public void setSong(String song) { //注入歌曲
		this.song = song;
	}
	public String getSong() {
		return song;
	}
	public String screamSong() {
		return song;
	}
	private Instrument instrument;
	public void setInstrument(Instrument instrument) {//注入乐器
		this.instrument = instrument;
	}
}
Instrumentalist有默认构造方法，所以可以声明为：（注：很重要，声明bean必须有构造方法，如果用set/get必须有无参构造方法）
<bean id="kenny" class="com.springaction.spingidol.Instrumentalist" />

注入简单值
<property>元素用于配置Bean属性，与<constructor-arg>类似，区别：一个用set方法注入值，一个用有参构造函数注入值
用setter赋予要表演的歌曲，还有表演者的年龄
<bean id="kenny" 
	class="com.springaction.spingidol.Instrumentalist">
	<property name="song" value="Jingle Bells" />
</bean>
一旦bean实例化，就会调用set方法，而且不仅可以set String类型还可以是任意类型，假如表演者有一个age成员变量，为int型
<bean id="kenny" 
	class="com.springaction.spingidol.Instrumentalist">
	<property name="song" value="Jingle Bells" />
	<property name="age" value="37" />
</bean>
其中"37"在调用setAge之前会自动转为int型

引用其他Bean
Kenny是一个天才演奏家，可以演奏实现了Instrument接口的任意乐器，比如萨克斯
public class Saxophone implements Instrument {
	public Saxophone() {}
	public void play() {
		System.out.println("TOOT TOOT");
	}
}

演奏之前先把萨克斯声明为一个bean，因为它没有属性需要设置，所以不用property
<bean id="saxophone" 
	class="com.springaction.spingidol.Saxophone"/ >

然后赋给Kenny演奏
<bean id="kenny2"
	class="com.springaction.spingidol.Instrumentalist">
	<property name="song" value="Jingle Bells" />
	<property name="instrument" ref="saxophone" />
</bean>

给Kenny一个表演环境，让Kenny排练
ApplicationContext ctx = new ClassPathCmlPllicationContext(
		"com/springaction/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("kenny");
performer.perform();
该例展示了Spring的一个重要理念，面向接口编程。面向接口和依赖注入实现了松耦合
Kenny还可以表演任何类型的乐器，只要它实现了Instrument接口

Kenny因为很关注个人卫生，所以不想与他人共享萨克斯，声明一个内部bean就可以解决这个问题
<bean id="kenny"
	class="com.springaction.spingidol.Instrumentalist">
	<property name"song" value="Jingle Bells" />
	<property name="instrument">
		<bean class="com.springaction.spingidol.Saxophone" />
	</property>
</bean>
还可以声明为constructor-arg，内部bean虽然可以有id，但是一般不会写，因为内部bean无法被别的bean引用
内部类会影响Spring XML的可读性，一般不要用

使用Spring命名空间p装配属性
<?xml ...
http://www.springframework.org/schema/p
...
可以用p:song="Jingle Bells"，等价<property name="song" value="Jingle Bells" />

装配集合
<list> 装配list类型的值，允许重复
<set> 装配set类型值，不允许重复
<map> 装配map类型值，名称和值可以是任意类型
<props> 装配properties类型的值，名称和值必须都是String型
上面这几个分别对应List，Set，Map和Properites

Hank可以演奏多种乐器，而且是同时演奏，相当于一个人的乐队
public class OneManBand implements Performer {
	public OneManBand() {}
	public void perform() throws PerformanceException {
		for(Instrument instrument : instruments) {
			instrument.play();
		}
	}
	private Collection<Instrument> instruments;
	public void setInstruments(Collection<Instrument> instruments) {
		this.instruments = instruments;
	}
}
<bean id="hank"
	class="com.springaction.spingidol.OneManBand">
	<property name="instruments">
		<list>
			<ref bean="guitar"/>
			<ref bean="piano"/>
			<ref bean="drum"/>
		</list>
	</property>
</bean>
set和list类似，只是用set元素

需要知道声音是哪个乐器产生的，可以用Map
public class OneManBand implements Performer {
	public OneManBand() {}
	public void perform() throws PerformanceException {
		for(String key : instruments.keySet()) {
			System.out.print(key + ":");
			instrument.play();
		}
	}
	private Map<String, Instrument> instruments;
	public void setInstruments(Map<String, Instrument> instruments) {
		this.instruments = instruments;
	}
}
<bean id="hank"
	class="com.springaction.spingidol.OneManBand">
	<property name="instruments">
		<map>
			<entry key="GUITAR" value-ref=="guitar"/>
			<entry key="PIANO" value-ref=="piano"/>
			<entry key="DRUM" value-ref=="drum"/>
		</list>
	</property>
</bean>
map有：key(String),key-ref(bean),value(String),value-ref(bean)

Properties.这个感觉不太常用，基本和Map类似
<props>
	<prop key="GUITAR">STRUM STRUM</prop>
	...

props和property不一样，不要弄混，property是bean的属性，props是类似map的配置，其中每一项是prop

还可以装配NULL,没有装配的其实默认为null，不过有时候需要确定必须为null，就用这个，感觉很少用
<property name="nullproperty"null/></property>


3.使用表达式装配（SpEL）
装配属性到运行时才能知道，则用表达式装配，Spring Expression Language
#{}就是SpEL的装配符，把括号里的值装配到property中
支持直接写，比如value="#{5}"和5是等价的，"#{'abc'}"等价"abc"，ref="#{saxophone}"和ref="saxophone"等价，但一般不这么用，它的主要用处如下：

carl可以模仿Kenny的歌曲，Kenny唱什么他就唱什么，就是只有当Kenny运行时才知道具体模仿什么歌
<bean id="carl"
		class="com.springaction.spingidol.Instrumentalist">
	<property name="song" value="#{kenny.song}" />
</bean>
执行效果等价于：(基于反射和动态加载)
Instrumentalist carl = new Instrumentalist();
carl.setSong(kenny.getSong);

还可以支持选method，如果有个songSelector的bean，它有一个selectSong的方法，返回什么，carl就唱什么
<property name="song" value="#{songSelector.selectSong()}"/>
如果carl唱的歌都是大写的<property name="song" value="#{songSelector.selectSong().toUpperCase()}"/>
如果selectSong返回空指针则不执行upper，<property name="song" value="#{songSelector.selectSong()?.toUpperCase()}"/>

如果需要调用Math类，则可以用T()运算符
<property name="nultiplier" value="#{T(java.lang.Math).random()}"/>

如果是简单的符号运算，就可以直接写
<property name="count" value="#{counter.toal*1.5 + 12}" /}
<property name="count" value="#{counter.toal==12}" /}
<property name="count" value="#{counter.toal==12 and counter.item gt 100}" /}

?支持类似if else功能
<property name="song"
		value="#{kenny.song != null ? kenny.song : 'Greensleeves'}" />

matches支持正则表达式

（注：所有等于，大于，小于，and，or等都是返回true或false）

访问集合成员
<property name="city" value="#{cities[2]}" />
从map中取
<property name="city" value="#{cities['Beijing']}"/>

<util:properties>可加载一个properties配置文件
<util:properties id="settings"
	location="classpath:settings.properties"/>
	<property name="accessToken" value="#{settings{'twitter.accessToken']}"/>
(注：就是properties类型，读取一个文件，然后访问其中的value，类似map，不过可以从文件总读取)

systemEnvironment环境变量
<property name="homePath" value="#{systemEnvironment['JAVA_HOME']}"/>

systemProperties可以查询Java程序的属性
(注：不要把过于复杂的逻辑放到SpEL中)



第三章 最小化Spring xml配置
autowiring（自动装配），autodiscovery（自动检查）
1.自动装配Bean
byName，自动装配ID与该属性名字相同的Bean
byType，自动装配类型与该属性相同的Bean，如果有多个则抛出异常，解决方法，可以用primary关键字声明那个是有先的
constructor，自动装载入参是这个bean的构造器
autodetect，首先尝试constructor，不成功则用byType
默认自动装配：如default-autowire="byName"，如果某个bean指定用某种装配，则可以覆盖默认方式
可以再xml配置,autowire="byType"但一般都是用注解

2.注解自动装配
命名空间<context:annotaion-config />,支持下面的注解：
(1)@Autowired:
自动装配Instrumentalist的instrument属性,之后就能移除装配instrument的property元素了
@Autowired
public void setInstrument(Instrument instrument) {
	this.instrument = instrument;
}
用@Autowired后会尝试对该方法用byType自动装配
不仅可以标注setter方法，还可以标注需要自动装配Bean的任意方法，包括构造器
@Autowired
public Instrumentalist(Instrument instrument){
	this.instrument = instrument;
}
xml中没有<constructor-arg>，构造器自动装配

还可以直接注解属性，删除setter方法,因为注解可以自动装载，不需要setter方法
@Autowired
private Instrument instrument;
@Autowired不受制于private，可以装载任意部分

如果注解没有找到Bean可以自动装载，则抛出异常，比后面抛出null异常要好
属性不一定要装配，null也可以接受则用required=false注解
@Autowired(required=false)
private Instrument instrument;

@Autowired可以注解构造器，只有一个构造器能@Autowired(required=true)，其他为false，如果有多个构造器，Spring会选择满足装配条件构造器中入参最多的那个（注，其实一般不会用注解构造器，了解）

如果有至少两个Bean符合条件，可以用@Qualifier注解出具体是哪个Bean，如
@Autowired
@Qualifier("guitar")
private Instrument instrument; //装载id为guitar的bean
看起来@Qualifier等价于byName，其实@Qualifier将搜索范围将为只有一个bean，而byName是要搜索全部的
还可以在Bean上直接用qualifier缩小范围
<bean class="com.springinaction.springidol.Guitar">
	<qualifier value="stringed">
</bean>

@Qualifier("stringed")
public class Guitar implements Instrument{...}

还可以自定义Qualifiler，基本思路就是对一个接口进行注解，然后直接用接口名作为一个限定器注解，了解

(2)@Inject:
@Autowired是Spring提供的，这个Spring支持，但不属于Spring的注解
@Inject与@Autowired类似，支持自动装配属性，方法，构造器，但不支持Qualifier，支持@Named("guitar")，基本和qualifier一样，支持自定义
（注：一般不会用Inject，了解，因为和Autowired功能太类似，有Autowired为什么要用Inject，Autowired毕竟是Spring提供的，支持性好一些）

(3)在注解中使用表达式
@Value，支持使用注解装配String类型和基本类型的值
@Value("abc")
private String song;//给song赋值为abc
更常用的是使用SpEL
@Value("#{systemProperties.myFavoriteSong}")
private String song;


3.自动检测Bean
<context:component-scan>，除了完成与<context:annotation-config>一样的工作，还允许Spring自动检测Bean和定义Bean，即不用<bean>就可以实现基本所有Bean的定义和装配
（<context:annotation-config>主要是消除property和constructor-arg，bean还是需要声明的）
首先用<context:component-scan>代替<context:annotation-config>，指定包（包括这个包里的包）
<beans xmlns=...
...>
	<context:componet-scan
		base-package="com.springination.springidol">
	</context:component-scan>
</beans>

(1)自动检测注解类
默认，<context:component-scan>查找构造型注入所标注的类：
@Component:通用构造型注解，标识该类为Spring组件
@Controller:标识该类为Spring MVC controller
@Resository:标注该类为数据仓库
@Service:标注该类为服务
如果上下文中仅有eddie和guitar两个Bean，可以用<context:component-scan>和@Component标注，这样就不用xml<bean>了
@Component
public class Guitar implements Instrument {
	public void play() {
		System.out.println("strum strum");
	}
}

@Component("eddie")
public class Instrumentalist implements Performer {
		...	
}
指定Bean id为eddie，默认是类名首字母小写，如instrumentalist
(注：Component相当于声明普通bean，可以规定bean id，不过一般都是用默认的小写首字母类名，其内部还可以用@Autowired等)

(2)过滤组件扫描
可以通过<context:include-filter>或<context:exclude-filter>为<context:component-scan>定义扫面范围
（了解，一般不会故意跳过某些类，如果需要直接就把该类写到别的包）


4.使用Spring基于Java的配置
使用@Configuration注解后，就不用<beans>了
这个基本思路是@Configuration注解命名空间等配置部分，这个部分用类实现，然后其余普通类用@Bean注解
（了解，这个基本不怎么用，因为配置用类还不如放在xml里，最常用的是@Autowired和@Controller,@Service等）



第四章 面向切面
1.什么是AOP
(1)通知(Advice）：规定切面是什么，何时使用，切面可以使用五中类型：
Before,方法调用之前调用通知
After,方法调用之后调用通知，无论方法是否成功
After-returnning,方法执行成功之后调用通知
After-throwing,方法抛出异常时调用通知
Around，通知包裹了通知的方法，在通知方法调用之前和调用之后执行的自定义行为

(2)连接点（Joinpoint）：在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时，抛出异常时等，切面代码可以李忠这些点插入到应用中

(3)切点(Pointcut)：何处，匹配导致要植入的一个或多个连接点

(4)切面(Aspect)：通知和切点的集合，即什么，在何时在何处

(5)引入(Introduction):允许向现有泪添加新方法或属性

(6)织入(Weaving):将切面织入到目标对象来创建新的代理对象的过程。目标对象有多个点可以织入：编译期，类加载期（需要ClassLoader），运行期（Spring AOP就是用这种方式，通过为目标对象动态创建一个代理对象）

Spring对AOP的支持
其实除了Spring AOP还有AspectJ AOP和JBoss AOP，这里关注Spring AOP
Spring提供了多中AOP支持，主要掌握声明和注解
Spring只支持方法连接点，因为Spring基于动态代理，所以只支持方法连接点，即以方法为基准点的之前之后等，其他框架可以支持字段和构造器等

2.使用切点单选择连接点（主要介绍基于AspectJ的，略）

3.在XML中声明切面
<aop:advisor>:通知器
<aop:after>：后置通知，不管被通知方法是否执行成功
<aop:after-returning>,<aop:after-throwing>,<aop:around>,<aop:aspect>,<aop:before>,<aop:pointcut>,<aop:declare-parents>
<aop:config>:顶层AOP配置，<aop:xxx>必须在<aop:config>内
<aop:aspectj-autoproxy>:用AspectJ注解驱动切面
选秀节目创建一个观众类
package com.springinaction.springidol;
public class Audience {
	public void takeSeats() { //表演之前
		System.out.println("The audience is taking seats");
	}
	public void applaud() { //表演之后
		System.out.println("CALP..");
	}
	public void demandRefund() { //表演失败后
		System.out.println("Boo! I want my money back!");
	}
}
先声明一个bean
<bean id="audience" class="com.springinaction.springidol.Audience"/>

声明前置后置通知
<aop:config>
	<!--注意，必须引用这个类-->
	<aop:aspect ref="audience">
		<aop:before pointcut=
			"execution(* com.springinaction.springidol.Performer.perform(..))"
			method="takeSeats"/>
		<aop:after-returning pointcut=
			"execution(* com.springinaction.springidol.Performer.perform(..))"
			method="applaud"/>
		<aop:after-throwing pointcut=
			"execution(* com.springinaction.springidol.Performer.perform(..))">
			method="demandRefund"/>
	</aop:aspect>
</aop:config>

pointcut属性都一样，为避免重复定义，用<aop:pointcu>
<aop:config>
	<!--注意，必须引用这个类-->
	<aop:aspect ref="audience">
		<aop:pointcut id="performance" expression=
			"execution(* com.springinaction.springidol.Performer.perform(..))"/>
		<aop:before pointcut-ref="performance"
			method="takeSeats"/>
		<aop:after-returning pointcut-ref="performance"
			method="applaud"/>
		<aop:after-throwing pointcut-ref="performance"
			method="demandRefund"/>
	</aop:aspect>
</aop:config>

声明环绕通知
这个有些特殊，参数必须为ProceedingJointPoint类型，其proceed方法标注了被通知方法执行的位置
public void watchPerformance(ProceedingJointPoint joinpoint) {
	try {
		System.out.println("The audience is taking seats");//表演前
		joinpoint.proceed();//执行被通知的方法，重要
		System.out.println("CALP.."); //表演后
	} catch (Exception e) {
		System.out.println("Boo! I want my money back!"); //表演失败后
	}
}
<aop:config>
	<!--注意，必须引用这个类-->
	<aop:aspect ref="audience">
	<!--切点就是要执行的方法-->
		<aop:pointcut id="performance" expression=
			"execution(* com.springinaction.springidol.Performer.perform(..))"/>
		<aop:around pointcut-ref="performance"
			method="watchPerformance"/>
	</aop:aspect>
</aop:config>

为通知传递参数，基本思路是在拦截传入被通知方法的参数，查看合法性等，用arg-names关键字，这个估计不常用，了解


4.注解
把Audience注解为一个切面
package com.springinaction.springidol;
@Aspect
public class Audience {
	@Pointcut("execution(* com.springinaction.springidol.Performer.perform(..))")
	public void performance() { //声明切点
	}

	@Before("performance()")
	public void takeSeats() { //表演之前
		System.out.println("The audience is taking seats");
	}

	@AfterReturning("performance()")
	public void applaud() { //表演之后
		System.out.println("CALP..");
	}

	@AfterThrowing("performance()")
	public void demandRefund() { //表演失败后
		System.out.println("Boo! I want my money back!");
	}
}
除了performance()方法，Audience类在实现没有变化，即POJO
<bean id="audience"
	class="com.springinaction.springidol.Audience" />
用<aop:aspectj-autoproxy>将在SPring上下文中创建一个代理类，他会自动代理一些bean，这些bean需要用AspectJ注解，即完全不需要xml声明

<aop:aspect>和注解都可以把一个POJO转为一个切面

around类似
@Around("performance()")


第五章 数据库（略，一般用ibatis）


第六章 事务管理
1.理解事务
全有或全无的操作为事务，例如银行转账
事务有原子性（所有操作都成功则事务成功，任意一个操作失败，则事务失败并回滚），一致性（一旦事务完成，不管成功还是失败，系统必须确保数据与预期的一致性），隔离性（事务彼此隔离，不能有同步的问题），持久性（一旦事务完成，结果必须持久化）

2.选择事务管理器
Spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理的任务委托给相关平台的事务实现，即由平台自己负责，Spring只是提供集成接口，比如DataSourceTransactionManager，为JDBC和ibatis提供事务支持
有好几个事务，比如Hibernate等， 这里重点掌握JDBC：
<bean id="transactonManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"/>
</bean>
dataSource是定义在上下文中的javax.sql.DataSource的Bean，DataSourceTransactionManager通过调用java.sql.Connection（通过DataSource获取）来管理事务，通过调用Connection的commit()提交，rollBack方法回滚

3.声明式事务
tx命名空间和@Transactional注解
(1)定义事务属性
a.传播行为：Spring定义7种传播行为，传播规则顶一个新的事务应该被启动还是挂起，或者方法时否要在事务环境中运行，如PROPAGATION_REQUIERED,该方法必须在事务中运行，如果事务存在则运行，否则启动新事务（注，基本就是规定方法与事务的关系，是否要抛异常还是启动新事物之类）

b.隔离级别
多个事务并发可能会导致：
脏读（读取了另一个事务尚未提交的数据，而且这个未提交的数据后来又回滚了，造成读取无效数据）
不可重复读（一个事务执行相同查询执行多次，每次得到结果都不同）
幻读（和不可重不复读类似，只是发生在一个事物读了几行数据，另一个事务插入数据，随后第一个事务就会发现原来不存在的数据）
理想状态是这些情况都不发生，事务之间完全隔离，但是会降低性能，只能用独占锁之类的方法，所以根据不同的需要提供了事务隔离级别
一般最常用ISOLATION_DEFAULT，即使用数据库默认级别
其他还有允许读尚未提交的数据变量，允许读并发事务已提交的数据等级别

c.其他，事务超时，只读，回滚规则等


(2)在XML中定义事务
tx命名空间添加到XML中,还必须基于AOP，即声明tx必须有AOP，因为一些声明式事务配置元素依赖于AOP元素
http://www.springframework.org/shecma/tx
http://www.springframework.org/schema/tx/spring-tx-3.0.xsd

tx:advice元素用于事务定义
<tx:advice id="txAdvice" transaction-manager="txManager">
	<tx:attributes>
		<tx:method name="save*" proopagation="REQUIRED"/>
	</tx:attributes>
</tx:advice>
基本就是上面这种，需要transaction-manager，具体的几个传播行为，隔离级别，超时，只读，回滚等可以在里面配置，<tx:advice>定义了AOP通知（是什么何时，没有定义何处）用于把事务边界通知给方法，而完整事务性切面需要定义一个advisor,基于AOP
使用txAdivce通知所有实现SpitterService接口的Bean
<aop:config>
	<aop:advisor
		pointcut="execution(* *..SpitterService.*(...))"
		advice-ref="txAdvice"/>
</aop:config>

(3)注解
<tx:annotation-driven transaction-manager="txManager" />

@Transactionanl(propagation=Propagation.SUPPORTS, readOnly=true)
public class ... {
	@Transactionanl(propagation=Propagation.REQUIRED, readOnly=true)
	public void xxx
}
(注，其实一般用默认的就好，自己往往不用定义注解，可以看懂就行，不用记，虽然如此但是还要知道transactonManager，dataSource等基本元素)



第七章 Spring MVC
首先熟悉下Servlet和Session
（Servlet:任何实现了这个Servlet接口的类
基本功能：
客户端请求该 Servlet；
加载 Servlet 类到内存；
实例化并调用init()方法初始化该 Servlet；
service()（根据请求方法不同调用doGet() 或者 doPost()，此外还有doHead()、doPut()、doTrace()、doDelete()、doOptions()）；
destroy()。

session 是在服务器端建立的，浏览器访问服务器会有一个sessionid，浏览器端通过sessionid定位服务器端的session,session的创建和销毁由服务器端控制
只有服务器端才有session.客户端被存到本地的是cookie，不过安全性低。所以不能放重要的数据，Session的id保存在客户机的cookie中

1.由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。
2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。
所以，总结一下：
Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

COOKIE和SESSION有什么区别？
cookie保存在客户端，session保存在服务器端，
cookie目的可以跟踪会话，也可以保存用户喜好或者保存用户名密码
session用来跟踪会话
）

1.Spring MVC起步
Spring MVC工作流程（具体看图）
1.Request首先到DispatcherServlet
2.DispatcherServlet把request传给HandlerMapping，HandlerMapping告诉DispatcherServlet该Request对应哪个Controller
3.DispatcherServlet再把request传给对应的Controller，经过处理后，Controller返回ModelAndView对象给DispatcherServlet
4.DispatcherServlet把View Name传给ViewResolver，ViewResolver解析后返回View给DispatcherServlet
5.DispatcherServlet把Model传给View，View把Response传给DispatcherServlet
5.DispatcherServlet把Response返回

DispatcherServlet充当Spring MVC的前端控制器，与其他Servlet一样必须在web.xml中配置
<servlet>
	<servlet-name>spitter</servlet-name>
	<servlet-class>
		org.springframework.web.servlet.DispatcherServlet
	</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>

注意，这个servlet的name很重要，默认DispatcherServlet会从一个基于Servlet名字的XML文件中加载Spring应用上下文，这里servlet name是spitter，则DispatcherServlet会尝试从spitter-servlet.xml（位于WEB-INF）文件中加载上下文（注意名字为<servlet-name>-servlet.xml）

还要声明DispatcherServlet处理哪些URL，一般是*.htm, /* 等，htm有问题就是只能处理htm的，而/*也有问题，如果静态资源也需要DispatcherServlet处理，更好的是：
<servlet-mapping>
	<servlet-name>spitter</servlet-name>
	<url-pattern>/<url-pattern>
<servlet-mapping>
把DispatcherServlet映射到/,然后配置<mvc:resources>，用它处理静态请求，这个元素时放在spring的ApplicationContext里的:
spitter-servlet.xml
<beans...>
<mvc:resources mapping="/resources/**"
				location="/resources/*" />

<beans>
静态资源请求也需要通过DispatcherServlet，需要告诉DispatcherServlet如何处理这些资源，刚好<mvc:resources>就是处理静态资源的。
<mvc:resources>建立了一个服务于静态资源的处理器，属性mapping设置为resources/**，它包含了Ant风格通配符以表明路径必修以/resources开始
以上配置说明所有以/resources路径开头的请求都会自动由应用程序更目录下的/resources提供服务，所以所有图片，css，js及其他静态资源都必须放在/resources目录下
（注，理解mvc:resources可处理静态资源即可）


2.编写基本控制器
(1)注解驱动的Spring MVC
Spirng自带好几个处理器映射，有的根据Bean的名字和URL映射等，不过一般用DispatcherServlet提供的DefaultAnnotationHandlerMapping（应该是如果在xml里没找到处理器映射Bean，则默认使用可以解析@Controller的HandlerMapping），DefaultAnnotationHandlerMapping将请求映射到使用@RequestMapping注解的方法，但是仅仅映射还不够，需要构建控制器时，把请求参数绑定到控制器方法参数上，所以需要在spitter-servlet.xml中添加
<mvc:annotation-driven/>

(2)首页控制器
@Controller
public class HomeController {
	public static final int DEFAULT_SPITTLES_PER_PAGE = 25;

	private SpitterService spitterService;

	@Inject
	public HomeController(SpitterService spitterService) {//构造注入
		this.spitterService = spitterService;
	}

	@RequestMapping({"/","/home"})
	public String showHomePage(Map<String, Object> model) {
		model.put("spittles", spitterService.getRecentSpittles(DEFAULT_SPITTLES_PER_PAGE));
		return "home"; //返回首页的视图名称
	}
}
因为@Controller是@Component注解的一种所以
<context:component-scan base-package="com.habuma.spitter.mvc" />

Map model是模型，控制器和视图之间传递的数据

请求处理方法的参数可以有多种，可以有model，还可以吧HttpServletRequest，HttpServletResponse，String或数字参数传进来，这些参数可以对应请求中的查询参数，cookie值，http请求头或其他选项等

测试Controller可以用Mockito，主要是mock方法和when方法
@Test
public void shouldDisplayRecentSpittles() {
	List<Spittle> expectedSpittles = asList(new Spittle(), new Spittle(), new Spittle());
	SpitterService spitterService = mock(SpitterService.class);//模拟，重要
	when(spitterService.getRecentSpittles(DEFAULT_SPITTLES_PER_PAGE)).thenReturn(expectedSpittles);

	HomeController controller = new HomeController(spitterService);
	String view = controller.showHomePage(model);
	assertEquals("home", view);
	assertSame(expectedSpittles, model.get("spittles"));
}

(3)解析视图
JSP，Velocity等，DispatcherServlet会找一个视图解析器来渲染Controller返回的逻辑视图
VelocityViewResolver,VelocityLayoutViewResolver（VelocityViewResolver的子类支持页面组合），InternalResolverViewResolver（将逻辑视图名解析为View对象，吧渲染任务委托给一个模板，如JSP）它通过逻辑名添加前缀和后缀来确定模板路径，前缀，如/WEB_INF/views/ 后缀，如.jsp，配置
<bean class=
		"org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="prefix" value="/WEB-INF/views/"/>
	<property name="suffix" value=".jsp"/>
</bean>
即在逻辑视图名前面和后面加前后缀，这里就是组成/WEB-INF/views/home.jsp,逻辑为home，组合为/WEB-INF/views/home.jsp
（注，ViewResolver的基本配置都类似，注意前后缀的意思）

(4)应用上下文
如果Spring应用上下文不是servlet-name-servlet的话，需要ContextLoaderListener来标注
<listener>
	<listener-class>
		org.springframework.web.context.ContextLoaderListener
	</listener-class>
</listener>
还需要告诉ContextLoaderListener需要加载那些配置文件 如果没有指定，则会查找/WEB-INF/applicationContext.xml文件，但这个文件没有吧应用上下文拆分为多个片段，如果需要指定一个或多个Spring配置文件，需要：
<context-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>
		/WEB-INF/spitter-security.xml
		classpath:service-context.xml
		classpath:persistence-context.xml
		classpath:dataSource-context.xml
	</param-value>
</context-param>
contextConfigLocation指定了一个列表，默认路径是相当与应用程序根目录的，classpath是的它们能够以资源方式在应用程序的类路径中加载


3.Controller的输入
@Controller
@RequestMapping("/spitter") //这个Controller的根URL,请求路径都以/spitter开头
public class SpitterController {
	private final SpitterService spitterService;

	@Inject
	public SpitterController(SpitterService spitterService) {
		this.spitterService = spitterService;
	}

	@RequestMapping(value="/spittles", method="GET")
	public String listSpittlesForSpitter(
			@RequestParam("spitter") String username, Model model) {
		Spitter spitter = spitterService.getSpitter(username);
		model.addAttribute(spitter);
		model.addAttribute(spitterService.getSpittlesForSpitter(username));
		return "spittles/list";
	}
}
@RequestParam表明它的值应该跟句请求中名为spitter的参数来获取，基于约定，如果处理方法的所有参数都没有用注解，则绑定到同名的查询参数上，即如果查询参数和Controller入参名字一样则自动绑定，如，这里如果请求参数为username则自动绑定，但是这样不好，还是用@RequestParam
Model对象内部很可能是一个Map<String, Object>，但是Model提供了几个方法来填充，如addAttribute()，其实它和put方法做的事情完全一样，只不过它能计算出map的key部分，就是不用自己写key，addAttribute自动填充key规则基本可以认为是首字母小写规则


4.处理表单
(1)展现注册表单
@RequestMapping(method=RequestMethod.GET, params="new")
public String createSpitterProfile(Model model) {
	model.addAttribute(new Spitter());//Model还可以加入一个类
	return "spitters/edit";
}
这里就是把类返回到前端，一般不这么用，了解

(2)处理表单输入
@RequestMapping(method=RequestedMethod.POST)
public String addSpitterFromForm(@Valid Spitter spitter,
								BindingResult bindingResult) {
	if(bingdingResult.hasErrors()) { //检查错误
		return "spitters/edit";
	}
	spitterService.saveSpitter(spitter);
	return "redirect:/spitters/" + spitter.getUsername();
}
重定向到/spitters/用户名，如/spitters/liming

处理带有变量的路径
@RequestMapping(value="/{username}", method=RequestMethod.GET)
public String showSpitterProfile(@PathVarible String username, Model model) {
	model.addAttribute(spitterService.getSpitter(username));
	return "spitters/view";
}
路径里{username}实际上是占位符，团队已合格了使用@PathVariable注解的username参数，即会填充路径里的username占位符

(3)校验输入
@Valid告诉Spring在将表单绑定在Spitter对象时，要校验，如果出错，校验错误将会作为参数BindingResult的形式传递进来
（注，了解，这里介绍了各种校验规则，一般都是用@xxx来写，不过校验一般是放在前端的，如果什么都在后台校验则效率太低）


5.文件上传
在注册表单添加一个文件上传域
修改SpitterController的addSpitterFromForm以接收上传的文件
在Spring中配置multipart文件处理器
(1)文件上传域
以下部分会被浏览器解析为上传
<tr>
	<th><label for="image">Profile image:</label></th>
	<td><input name="image" type="file" />
</tr>
还有一部分JSP的表单，可以忽略，因为不同的前端处理不一样，基本知道需要有个上传的就行

(2)接收文件上传
@RequestMapping(method=RequestMethod.POST)
public String addSpitterFromForm(@Valid Spitter spitter,
	BindingResult bindingresult,
	//重点。value是前端的变量名，required指是否必须，而类型是MultipartFile，多媒体都用这个类型
	@RequestParam(value="image",required=false) MultipartFile image) {
	if(bingdingResult.hasErrors()) { //检查错误
		return "spitters/edit";
	}
	spitterService.saveSpitter(spitter);
	try {
		if(!image.isEmpty()) {
			validateImage(image);
			saveImage(spitter.getId() + ".jpg", image);
		}
	} catch (xxx) {
		bindingResult.reject(e.getMessage());
		return "spitters/edit";
	}
	return "redirect:/spitters/" + spitter.getUsername();
}

调用wirteByteArrayToFile保存jpg
File file = new File(xxx);
FIleUtils.writeByteArrayToFile(file, image.getBytes());

(3)Spring中文件上传
DispatcherServlet不知道如何处理multipart表单，需要一个multipart解析器把POST中的multipart数据抽取出来，multipart的bean id必须为multipart，否则DispatcherServlet会找不到
<bean id="multipartResolver" class=
	"org.springframework.web.multipart.commons.CommonsMultipartResolver"
	p:maxUploadSize="500000"/>
规定了最大上传大小



第八章 Spring Web Flow
Spring Web Flow是一个Web框架，适用于元素按规定流程运行的程序，它是Spring MVC的扩展，支持开发基于流程的应用程序
Spring Web Flow不是Spring框架的一部分，是一个子项目，所以需要下载jar包
首先，声明命名空间
http://www.springframework.org/echema/webflow-config

织入流程执行器，<flow:flow-executor>会创建一个流程执行器：
<flow:flow-executor id="flowExecutor" flow-registry="flowRegistry" />
flowExecutor负责创建和执行流程，但并不负责加载流程定义，这个是由flow registry负责

配置流程注册表
<flow:flow-registry id="flowRegistry" base-path="/WEB-INF/flows">
	<flow:flow-location-pattern value="*-flow.xml"/>
</flow:flow-registry>
类似ViewResolver，这个也是前后缀，在/WEB-INF/flows查找，以-flow.xml结尾都视为流程的定义
还可以直接指定
<flow:flow-registry id="flowRegistry">
	<flow:flow-locatoin id="pizza"
			path="/WEB-INF/flows/springpizza.xml" />
</flow:flow-registry>
注意，如果没有id，则用xml的名字为id，springpizza

处理流程请求
FlowHandlerMapping帮助DispatcherServlet将请求流程发送给Spring Web Flow
<bean class="org.springframework.webflow.mvc.servlet.FlowHandlerMapping">
	<property name="flowRegistry" ref="flowRegistry" />
</bean>

视图状态（<view-state>）,可以是Spring支持的任意视图，如JSP，<view-state id="welcome" />即展现逻辑视图welcome，也可以明确说明
<view-state id="welcome" view="greeting" />

行为状态,<action-state>，出发Bean的方法并根据调用的结果转移状态
<action-state id="saveOrder">
	<evaluate expression="pizzaFlowActions.saveOrder(order)"/>
	<transistion to="thankYou" />
</action-state>
evaluate是要做的事情，即pizzaFlowActionsbean的saveOrder方法

决策状态
<decision-state id="checkDeliverArea">
	<if test="xxx.yyy()"
		then="addCustomer"
		else="deliveryWarning" />
</decision-state>
如果xxx bean的yyy方法返回true则跳到addCutomer

子流程状态
<subflow-state id="order" subflow="pizza/order">
	<input name="order" value="order"/>
	<transition on="orderCreated" to="payment" />
</subflow-state>
subflow-state允许在一个正在执行的流程中调用另一个流程，类似一个方法中调另一个方法
input类似于入参，如果子流程的end-state是orderCreated,则跳转到流程payment

结束状态
<end-state id="cutomerReady">
就是流程的结束

转移流程
<transition to="xxx"/> 跳转到xxx流程
（这块看起来比较乱，实际就是用transition在各个状态之间跳转，在这之前还要注册Servlet和配置，其中view-state是前端要显示的页面，行为状态执行函数）



第九章 Spring Security
安全其实是一个切面，而Spring Security是基于Spring AOP和Servlet Filter实现的
Security的xml一般单独放在一个文件里，如spitter-security.xml，加命名空间，否则需要对需要加安全的bean加security前缀

代理Servlet过滤器
<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>
		org.springframework.web.filter.DelegatingFilterProxy
	</filter-class>
</filter>
DelegatingFilterProxy将任务分配给servlet.Filter实现类，这个类作为一个bean注册在Spring xml中
DelegatingFilterProxy的filter-name是有意义的，Spring Security自动创建id为springSecurityFilterChain的Bean，名字必须一样

基本配置
<http auto-config="true">
	<intercept-url pattern="/** access="ROLE_SPITTER" />
</http>
对/**访问控制，有ROLE_SPITTER权限才行，auto-config可以省很多配置，包括登录页面，HTTP基本认证，退出。
等价：
<http>
	<form-login />
	<http-basic />
	<logout />
	<intercept-url pattern="/** access="ROLE_SPITTER" />
</http>

通过表单进行登录
如果用auto-config，则登录也就是/spring_security_login，不过一般都需要自定义登录页面
<http auto-config="true" use-expression="false">
	<form-login login-processing-url="/static/j_spring_security_check"
				login-pagre="/login"
				authentication-failure-url="/login?login_error=t"/>
</http>
登录页面/login，认证失败跳转/login?login_error=t，login-processing-url是登录表单提交回来进行用户认证的URL（没明白）

处理基本认证
通过HTTP请求本身对访问用户认证，就是浏览器弹出输入用户名密码的情况
<http-basic>，没有什么配置，只有开启和关闭两种选项（书上没说明具体情况）

拦截请求
<intercept-url pattern="/** access="ROLE_SPITTER" /> 拦截所有页面
<intercept-url pattern="/admin/*** access="ROLE_ADMIN"> /admin需要ROLE_ADMIN	权限
可以用任意条<intercept-url 保护，但是起作用顺序是由上而下，如果把拦截所有页面的放在上面则下面的就会失效

安全表达式
如hasRole(role),isAuthenticated(),isRememverme等
<intercept-url pattern="/admin/***" access="hasRole('ROLE_ADMIN') and hasIpAddress('192.xxx)" />
这样可以为一个路径加多个限制，通过and

HTTPS
<intercept-url pattern="/spitter/form" requires-channel="https"/>

保护前端的元素
这个是保护JSP元素的，比如在网页首部显示欢迎之类的
欢迎 <security:authentication property="principal.username" />
property是认证用户对象的属性，可以包括credentials,authorities,principal等，Velcocity也有一套类似的命令
如果想把property赋给一个变量则：
<security:authentication property="principal.username" var="userid"/> userid存的是username

认证用户
基本就是从不同的数据源取用户，认证
就是用户名密码权限，基于配置的
还需要一个认证管理器，认证管理器把认证的任务委托给一个或多个authentication-provider，这个service帮忙认证
<authentication-manager>
	<authentication-provider user-service-ref="userService" />
</authentication-manager>
<authentication-provider>
	<user-service id="userService">
		<user name="habuma" password="letmein" authorities="ROLE_SPITTER,ROLE_ADMIN"/>
		<user name="limei" password="letmein" authorities="ROLE_SPITTER,ROLE_ADMIN"/>
	</user-service>
</authentication-provider>

还可以通过JDBC <jdbc-user-service>代替user-service，LDAP，<ldap-user-service>代替user-service，还可以加密<password-compare hash="md5"...>(了解)

remember-me
在http中加一个remember-me
<http auto-config="true">
	...
	<remember-me key="spitterKey" token-validity-seconds="200000"/>
</http>
cookie中存一个token，指定有效时间20000，cookie中的token包括用户名，密码，过期时间和秘钥，都是MD5加密

保护方法调用
@Secured注解
@Secured("ROLE_SPITTER")
public voiid xxx() {
	...
}
只有ROLE_SPITTER权限才能调用

（
基于数据库的管理用户和角色来使用spring security（企业一般是用这种）
一般会重写系统提供的UserDetailsService接口，然后根据前端传过来的用户名去数据库查询出基本信息根据数据库其权限给其添加权限
@Service("userServiceImpl")
public class UserServiceImpl implements UserService, UserDetailsService {
    @Autowired
    private UserDao userdao;
    public List<DBUser> userquery(String username) {
        return userdao.userquery(username);
    }
    public UserDetails loadUserByUsername(String username)
        throws UsernameNotFoundException {
        UserDetails deuser = null; 
         try {  
  
             // 搜索数据库以匹配用户登录名.  
             // 我们可以通过dao使用JDBC来访问数据库  
             List<DBUser> luser=userdao.userquery(username);
         if(luser == null )
             return deuser;
         DBUser user =  luser.get(0);
         // Populate the Spring User object with details from the dbUser  
         // Here we just pass the username, password, and access level  
         // getAuthorities() will translate the access level to the correct  
         // role type  
        //注意这个user是userDetail包里面的类
           //而dbuser也是userDetail包里面的类
           deuser = new User(user.getUsername(), user.getPassword().toLowerCase(), true, true, true, true,getAuthorities(user.getAccess()));  
         } catch (Exception e) {  
         
             throw new UsernameNotFoundException("Error in retrieving user");  
         }  
        return deuser;
}

    @SuppressWarnings("deprecation")
    public Collection<GrantedAuthority> getAuthorities(Integer access) {  
  
            List<GrantedAuthority> authList = new ArrayList<GrantedAuthority>(2);  
            // 所有的用户默认拥有ROLE_USER权限   
            authList.add(new GrantedAuthorityImpl("ROLE_USER"));  
            // 如果参数access为1.则拥有ROLE_ADMIN权限  
            if (access.compareTo(1) == 0) {         
                authList.add(new GrantedAuthorityImpl("ROLE_ADMIN"));  
            }  
            //返回权限列表，像管理员账号，zhangsan。返回的authList的值为 :[ROLE_USER, ROLE_ADMIN]，而普通用户返回的值为[ROLE_USER]
                return authList;  
     }  
   
}
spring security的工作执行原理

       1）web容器启动加载系统资源和权限列表

       2）用户发出请求

       3）过滤器拦截

       4）取得请求资源所需权限

       5）匹配用户拥有权限和请求权限，如果用户没有权限执行第六步，否则执行第七步

       6）登录

      7）验证并授权
）



第十章 使用远程服务
这里主要关注Web Service，其他还有几种方式，可以暂时不关心
发布和使用Web Service
SOA，面向服务的架构，SOA的核心是应用程序可以依赖一组公共的服务，而不是每个应用都重新实现重复的功能
主要是JAX-WS和CXF，CXF类似XFire2，由于XFire停滞，所以一般用CXF。这里重点讨论JAX-WS
1.创建JAX-WS端点
Spring提供了SimpleJaxWsServiceExporter，
在Spring中自动装配JAX_WS端点
@WebService注解被认为是服务端点，@WebMethod注解被认为是操作
package com.habuma.spitter.remoting.jaxws;
import javax.jws.WebMethod;
import javax.jws.WebService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import xxx;

@Component
@WebService(serviceName="SpitterService")
public class SpitterServiceEndpoint {
	@Autowired
	SpitterService spitterService;

	@WebMethod
	public void addSpittle(Spittle spittle) {
		spitterService.saveSpittle(spittle);
	}

	@WebMthod
	...//其余方法，类似，都是委托给spitterService
}
<bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"
	p:baseAddress="http://localhost:8888/services/"/>
注意baseAddress配置，这个webservice URL是http://localhost:8888/services/SpitterService
其wsdl就是http://localhost:8888/services/SpitterService?wsdl

2.在客户端代理JAX-WS服务
JaxWsPortProxyFactoryBean可以让在Spring中装配和使用Web Service，就像这个Web Service是本地的POJO一样
基本原理是生成一个代理，调用者调用这个代理，代理去通过SOAP访问WebService
<bean id="spitterService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean"
	p:wsdlDocumentUrl="http://http://localhost:8888/services/SpitterService?wsdl"
	p:serviceName="spitterService"
	p:portName="spitterServiceHttPort"
	p:serviceInterface="com.habuma.spitter.service.SpitterService"
	p:namespaceUri="http://spitter.com"/>
JaxWsPortProxyFactoryBean通过WSDL为服务创建代理，JaxWsPortProxyFactoryBean生成的代理实现了serviceInterface属性SpitterService接口
查看WSDL的<wsdl:port>和<wsdl:service>的name，根据这个来设置
	p:serviceName="spitterService"
	p:portName="spitterServiceHttPort"



第十一章 为Spring添加REST功能
1.了解REST
REST的常见错误认识：一种基于URL的Web服务；另一种RPC，就像SOAP，区别只是基于SOAP和URL而已
事实是REST和RPC几乎没有关系，RPC是面向服务的，关注行为和动作；REST是面向资源的，强调描述应用程序的事物和名词。
尽管URL在REST中起了重要作用，但并不是REST的全部
REST，representational，State，Transfer，表述性状态转移，REST就是将资源的状态以最合适的形式从服务器转移到客户端

Spring如何REST支持：
Controller可以处理所有HTTP方法，包括GET,PUT,DELETE,POST;
@PathVariable注解可以将变量输入作为URL的一部分，处理参数化的URL；
通过Spring View和ViewResolver，资源可以以包括xml，json等各种形式表述；
使用ContentNegotiatingViewResolver选择最适合客户端的表述；
基于View的可以用@ResponseBody注解和各种HttpMethodConverter来实现；
@responseeBody注解和HttpMethodConverter实现可以将传入HTTP数据转化为传入Contoller方法的Java对象
RestTemplate简化客户端对REST资源的使用


2.编写面向资源的Controller
RESTLess URL面向动作，如http://localhost:8080/Spitter/displaySpittle.htm?id=123
REST URL不仅可以定位资源还可以标识资源
http://localhost:8080/Spitter/spittles/123

执行REST动作：
@RequestMapping(method=RequestMethod.GET)
public String showSpittle(@RequestParam("id") long id, Model model) {
	model.addAttribute(spitterService.getSpittleById(id));
	return "spittles/view";
}

@RequestMapping(value="{/id}", method=RequestMethod.PUT)
@ResponseStatus(HttpStatus.NO_CONTENT)
public void putSpittle(@PathVariable("id") long id, @Valid Spittle(spittle)) {
	spitterService.saveSpittle(spittle);
}

@RequestMapping(value="{/id}", method=RequestMethod.PUT)
@ResponseStatus(HttpStatus.NO_CONTENT)
public void putSpittle(@PathVariable("id") long id, @Valid Spittle(spittle)) {
	spitterService.deleteSpittle(spittle);
}

使用POST创建资源
@RequestMapping(method=RequestMethod.POST)
@ResponseStatus(HttpStatus.CREATED) //201 http
public @ResponseBody Spittle createSpittle(@Valid Spittle spittle, BindingResult result, HttpServletResponse response) throws BindException {
	if(result.hasErrors()) {
		throw new BindException(result);
	}

	spitterService.saveSpittle(spittle);
	response.setHeader("Location", "/spittles/" + spittle.getId());
	return spittle;
}


3.表述资源
ContentNegotiaingViewResolver会确定请求的类型(通过Accept头)，然后找到请求的最佳视图
<bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
	<property name="mediaTypes">
		<map>
			<entry key="json" value="application/json" />
			<entry key="xml"  value="text/xml" />
			<entry key="htm"  value="text/html" />
		</map>
	</property>
	<property name="defaultContentType" value="text/html" />
</bean>

客户端提交PUT请求，包含json
(Content-Type必须是application/json，需要Jackson json库)
@RequestMapping(value="/{username}", method = RequestMethod.PUT,
				headers = "Content-Type=application/json")
@ResponseStatus(HttpStatus.NO_CONTENT)
public void updateSpitter(@PathVariable String username, @RequestBody Spitter spitter) {
	spitterService.saveSpittert(spitter);
}


4.REST客户端
public Spittle[] retrieveSpittlesForSpitter(String username) {
	try {
		HttpClient httpClient = new DefaultHttpClient();
		//构建URL
		String spitterUrl = "http://localhost:8080/Spitter/spitters/" + username + "/spittles";
		HttpGet getRequest  = new HttpGet(spittleUrl);
		getRequest.setHeader(new BasicHeader("Accept", "application/json"));
		HttpResponse response = httpClient.execute(getRequest);
		HttpEntity entity = response.getEntiry();
		ObjectMapper mapper = new ObjectMapper();
		return mapper.readValue(entity.getContent(), Spittle[].class);
	} catch (IOException e) {
		throw xxx;
	}
}


5.resttemplate
可以避免冗余代码
public Spittle[] retrieveSpittlesForSpitter(String username) {
	ResponseEntiry<Spittle[]> response = new RestTemplate().getForEntity(
		"http://localhost:8080/Spitter/spitters/{spitter}/spittles",
		Spittle[].class, username);
	if(response.getStatusCode() == HttpStatus.NOT_MODIFIED) {
		Excpetion
	}
	return response.getBody();
}
其他操作类似，即简化代码


HiddenHttpMethodFilter是在浏览器表单发送PUT和DELET请求时需要用的，由于PUTheDELETE请求表单，都会以PUT处理，这个Filter是把DELETE解析出，然后在DispatcherServlet之前转换为DELET并交给method处理（了解）



第十二章 Spring消息
1. JMS
Java消息服务（Java Message Service，JMS）是面向异步消息而制定的标准API，客户端发送消息，然后继续执行，不需要等待
JMS中两个重要概念：消息代理，目的地（可以想象成邮局和收件人，寄件人把信给邮局后就走了，不需要等待回信，邮局负责寄送）
JMS中有两种类型的目的地，队列（点对点模型）和主题（发布订阅模型）

点对点模型
一个消息有一个发送者和一个接收者，中间一个消息队列。
JMS中可以有多个接收者监听队列，类似银行排队，多个柜员（接收者）多个客户（消息），客户相当于消息，投递给一个接收者，但具体是哪个不知道，由系统分配

发布订阅模型
消息会发送一个主题，多个接收者可以监听一个主题，但是不同的是消息会发送给所有订阅者，类似订阅报纸
发布者不知道订阅者，消息被发送到一个特定主题，而发布者不知道谁在监听这个主题，更类似把报纸发布到报刊亭，想买的就去买

JMS优点
无需等待，提高性能
面向消息和解耦，与RPC不同，JMS是以数据为中心，即客户端没有与特定方法绑定，任何可以处理数据的队列或主题订阅者都可以处理由客户端发送的消息，而客户端不必了解远程服务的任何规范
位置独立，同步RPC服务需要网络地址来定位，如果服务IP或端口变了，客户端必须调整，否则无法访问服务。JMS客户端只需要知道通过哪个队列或主题获取消息，而不要关注服务来自哪里
确保投递，同步服务必须监听指定IP和端口号，如果服务崩溃了客户的将不能继续处理。JMS发送消息，即使消息发送时服务不可用，消息也会被存储起来，直到服务可用


2.在Spring中搭建消息代理（ActiveMQ）
activemq jar包导入进来就能用
用ActiveMQ做消息代理，必须配置JMS连接工厂，让它知道如何连接到ActiveMQ，ActiveMQConnectionFactory是ActiveMQ自带的连接工厂
<bean id="connectionFactory"
	class="org.apache.activemq.spring.ActiveMQConnectionFactory">
	<property name="brokerURL" value="tcp://localhost:61616"/>
</bean>

(1)用ActiveMQ的Spring配置命名空间来声明连接工厂
(注意，Spring中命名空间很重要，有了命名空间xmlns,ns namespace,才能用各种元素)
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns=...
...
	xmlns:jms="http://www.springframwork.org/schema/jms"
	xmlns:amp="http://activemq.apahce.org/schema/core"
...
</benas>
然后用<amq:connectionFactory>声明连接工厂
<amq:connectionFactory id="connectionFactory"
	brokerURL="tcp://localhost:61616">
注意，如果使用不同的消息代理实现，则不一定有Spring命名空间，那就需要用<bean>来装配连接工厂
（
注：估计是这样
<bean id="connectionFactory"
	class="连接工厂class">
	<property name="xxx" value="path"/>
</bean>
如果Spring提供了命名空间，则直接用指定的元素就可以配置，如<amq:connectionFactory，不需要bean，不用class
）

(2)声明ActiveMQ消息目的地
可以是一个队列或主题
<bean id="queue" class="org.apache.activemq.command.ActiveMQQueue">
	<constructor-arg value="spitter.queue">
</bean>

<bean id="topic" class="org.apache.activemq.command.ActiveMQTopic">
	<constructor-arg value="spitter.topic">
</bean>

还可以用ActiveMQ元素<amq:queue>
<amq:queue id="queue" physicalName="spitter.queue" />

主题用<amq:topic>
<amq:topic id="topic" physicalName="spitter.topic" />


3.使用Spring的JMS模板
JMS为Java开发者提供了与消息代理进行交互来发送和接收消息的标准API，每一个消息代理都实现了JMS，所以不用因为不同的消息代理而学习私有API
JMS虽然为所有消息代理提供了统一的接口，但是与JDBC的问题一样，太多冗余代码处理异常等，真正业务代码很少
用Spring的JmsTemplate可以解决这个问题

(1)在Spring配置文件中声明bean
<bean id="jmsTemplate"
	class="org.springframework.jms.core.JmsTemplate">
	<property name="connectionFactory" ref="connectionFactory" />
</bean>
JmsTemplate必须知道如何连接到消息代理，所以connectionFactory属性设置实现了JMS的ConnectionFactory接口的Bean引用

(2)发送消息
public interface AlertService {
	void sendSpittleAlert(Spittle spittle);
}

public class AlertServiceImpl implements AlertService {
	public void sendSpittleAlert(Spittle spittle) {
		jmsTemplate.send( //send方法发送消息
			"spittile.alert.queue", //指定目标
			new MessageCreator() {
				public Message createMessage(Session session)
					throws JMSException {
					return session.createObjectMessage(spittle); //创建消息
				}
			}
		)
	}

	@Autowired
	JmsTemplate jmsTemplate; //注入JMS Template
}
send方法会负责JMS连接，会话并发送消息；MessageCreator内部类用于构造消息，其createMessage方法通过session构建了消息
jmsTemlate会处理连接，管理会话，异常（这些代码如果不用temlate，必须自己写），JmsTemlate会把所有JMSException（注意，其他异常不能自动转换）转换从非检查型异常
（对于因为编程错误而导致的异常，或者是不能期望程序捕获的异常（解除引用一个空指针，数组越界，除零，等等），为了使开发人员免于处理这些异常，一些异常被命名为非检查型异常（即那些继承自 RuntimeException 的异常）并且不需要进行声明）

如果目的地址固定，则可以配置到xml里
<bean id="jmsTemplate"
	class="org.springframework.jms.core.JmsTemplate">
	<property name="connectionFactory" ref="connectionFactory" />
	<property name="defaultDestinationName" value="spittle.alert.queue"/>
</bean>
调用JmsTemplate就不用第一个参数了
		jmsTemplate.send(
			new MessageCreator() {
		...

(3)接收消息
public Spittle getAlert() {
	try {
		ObjectMessage receivedMessage = 
			(ObjectMessage) jmsTemplate.receive(); //调用receive方法接收消息
		return (Spittle) receiveMessage.getObject(); //获取对象
	} catch (JMSException e) {
		throw JmsUtils.convertJmsAccessException(e);//转换后抛出
	}
}
ObjectMessage转换类似Object转具体类型，还有这里处理异常的原因：只有用jmsTemplate才能自动转换异常，而getObject不是JmsTemplate的方法，所以没有自动异常转换
receive方法是同步的，接收者会一直阻塞在receive，直到消息到来或者超时，这时JmsTemplate的缺点，用消息驱动POJO可以避免


4.创建消息驱动的POJO（MDP）
(1)创建消息监听器(POJO)
package com.habuma.spitter.alerts;
import com.habuma.spieeter.domain.Spittle;

public class SpittleAlertHandler {
	public void processSpittle(Spittle spittle) {
		...
	}
}

(2)配置监听器
在Spring中把POJO配置为消息监听器,Spring的jms命名空间提供了需要的元素。
首先把Handler声明为bean（注：只有声明为bean才能被引用）
<bean id="spittleHandler"
	class="com.habuma.spitter.alerts.SpittleAlertHandler" />

然后，把Handler转化为消息驱动POJO，这需要注册消息监听器
<jms:listener-container connection-factory="connectionFactory">
	<jms:listener destination="spitter.alert.queue" ref="spittleHandler" method="processSpittle" />
</jms:listener-container>
消息监听容器是一个特殊的bean，可以监控JMS目的地并等待消息到达，一旦消息到达就取出消息并发送给感兴趣的监听器（注，监听者模式，通过回调函数实现）
<jms:listener-container>定义容器，其中的<jms:listener>都用其中配置的connection-factory来监听消息，这里其实可以不配置连接工厂，因为默认就是connectionFactory（注：估计是可以自动装载，因为上下文中只有一个连接工厂bean）
<jms:listener>标识一个Bean和一个处理消息方法，当消息到达destination，则调用ref中的method


5.使用基于消息的RPC
Spring提供了两种基于消息的RPC方案：
Spring提供的JmsInvokerServiceExporter，可以把Bean导出为基于消息的服务，客户端使用JmsInvokerProxyFactoryBean来调用这些服务。
Lingo通过JmsServiceExporter和JmsProxyFactoryBean提供了类似的基于消息的远程调用方法，支持异步调用

(1)Spring基于消息的RPC
Spring提供了许多将Bean导出为远程服务的方式，这里是导出基于JMS的服务
package com.habuma.spitter.alerts;
import com.habuma.spitter.domain.Spittle;
public interface AlertService {
	void sendSpittleAlert(Spittle spittle);
}

@Component("alertService")
public class AlertServiceImpl implements AlertService {
	...
	public void sendSpittleAlert(Spittle spittle) {
		...
	}
}

因为AlertServiceImpl用了@Component标注，所以Spring会自动发现并注册为Spring Applicaton Context中ID为alertService的Bean，配置JmsInvokerServiceExporter时会引用这个bean：
<bean id="alertSerivceExporter
	class="org.springframwork.jms.remoting.JmsInvokerServiceExporter"
	p:service-ref="alertService"
	p:serviceInterface="com.habuma.spitter.alerts.AlertService" />
(注：往往需要导出给其他系统用的bean都需要接口，对方通过接口来调用，估计是接口可以接收所有其实现类，而不局限于某个类，因为对方不知道这个bean具体实现了那个类，用接口可以兼容所有实现该接口的类)
具体JMS通信细节由JmsInvokerServiceExporter负责，而且JmsInvokerServiceExporter可以作为JMS监听器
<jms:listener-container connection-factory="connectionFactory">
	<jms:listener destination="spitter.alert.queue" ref="JmsInvokerServiceExporter" />
</jms:listener-container>

访问JMS服务调用JmsInvokerProxyFactoryBean，它隐藏了访问服务的细节，并提供了一个接口用于客户端与服务端进行交互，其实就是代理了通过JmsInvokerServiceExporter所导出的JMS服务
<bean id="alertService"
	class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean">
	<property name="connectionFactory" ref="connectionFactory" />
	<property name="queueName" value="spitter.alert.queue" />
	<property name="serviceInterface" value="com.habuma.spitter.alerts.AlertService" />
</bean>
connectionFactory，queueName指定了RPC消息会在连接工厂中配置的消息代理里面名为spitter.alert.queue的队列（注：工厂中配置用ActiveMQ，而ActiveMQ又也可配置队列，消息或主题）
serviceInterface指定了代理服务使用com.habuma.spitter.alerts.AlertService发布
Spring提供的方式并不是唯一和最好的，还有lingo

(2)使用lingo实现异步RPC
支持异步，当客户端发起请求时，服务端不需要处可用状态

导出异步服务
通过JmsServiceExporter，和JmsInvokerServiceExporter配置类似
<bean id="alertSerivceExporter
	class="org.logicblaze.lingo.jms.JmsInvokerServiceExporter"
	p:service-ref="alertService"
	p:serviceInterface="com.habuma.spitter.alerts.AlertService"
	p:destination-ref="alertServiceQueue"
	p:service-ref="alertService"
	p:serviceInterface="com.habuma.spitter.alerts.AlertService" />
<amq:queue id="alertServiceQueue" physicalName="spitter.alert.queue">
因为JmsServiceExporter不能作为监听器，所以必须通过ConnectionFactory书信配置JMS连接工厂，通过destination配置消息目的地

代理异步服务
Spring调用JmsInvokerServiceProxy代理方法时，即使是JMS服务也只能等待
Lingo的JmsProxyFactoryBean可以把没有返回值的方法作为异步方法
<bean id="alertService"
	class="org.springframework.jms.remoting.JmsProxyFactoryBean">
	<property name="connectionFactory" ref="connectionFactory" />
	<property name="queueName" value="spitter.alert.queue" />
	<property name="serviceInterface" value="com.habuma.spitter.alerts.AlertService" />
	<bean id="metadataStrategy"
		class="org.logicblaze.lingo.SimpleMetadataStrategy">
		<constructore-arg value="true">
</bean>
metadataStrategy规定了异步的策略，true表示这个服务的void的函数被视为单向的，可以直接返回而不需要等待，如果不配置metadataStrategy或为false则和Spring提供的方法一样，变成同步的了


