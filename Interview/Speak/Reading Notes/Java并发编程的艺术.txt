第一章 并发编程的挑战
1. 上下文切换
任务从保存到加载的过程就是一次上下文切换
线程越多不一定越快，因为有线程创建和上下文切换开销
Lmbench3，一个性能分析工具，可以测量上下文切换时长
vmstat可以测量上下文切换的次数

减少上下文切换方法：
无锁并发编程：ID按照Hash算法分段，不同线程处理不同段，ConcurrentHashMap
CAS算法，Java Atomic包基于CAS
避免创建不需要的线程
协程：单线程里多任务调度，单线程维持多个任务间切换（了解）

jstack dump pid=3117进程里的线程
sudo -u admin /opt/ifeve/java/bin/jstack 3117 > dump3117

2.死锁
避免死锁的方法：
避免一个线程同时获得多个锁
避免一个线程在锁内同时占用多个资源，尽量保证每个锁保护一个资源
使用lock.tryLock(timeout)
数据库中加锁和解锁必须在一个数据库连接里

3.资源限制
硬件资源限制可考虑用集群并发执行，软件资源限制可考虑用资源池，比如数据库连接池，调用对方WebService时只建立一个连接（单例）

注： 多用JDK并发包提供的工具类和容器，这些类都经过优化和测试，可用性很高


第二章 Java并发机制的底层实现原理
Java-编译-Java字节码-JVM-JVM执行字节码-汇编指令-CPU
Java依赖于JVM和CPU指令

1. volatile
多处理器中保证共享变量的可见性，可见性是当一个线程修改一个共享变量时，另一个线程可以读到这个修改的值
volatile比synchronized成本低，因为它不会引起上下文切换
volatile的原理：volatile最终会转化为汇编的Lock指令，而Lock前缀指令在多处理器中会引发两件事情：
1）将当前处理器缓存的数据写回系统内存
2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

2. synchronized
普通同步方法，锁是当前对象；静态同步方法，锁是当前类的Class对象；同步方法快，锁是synchronized括号里配置的对象
实现原理：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，其中代码块同步用monitorenter和monitorexit指令实现，而方法同步的实现方式JVM里没有细说，不过也可以用monitorenter和monitorexit指令实现
编译后，monitorenter指令插入到同步代码块的开始，monitorexit指令插入到结束和异常处，JVM保证两个成对出现，任何一个对象都有一个monitor与之关联，线程执行monitorenter指令尝试获取对象关联的Monitor的所有权，即尝试获取对象锁

synchronized用的锁是存在Java对象头里的，如果对象是数组类型则用3个字宽存储对象头，非数组类型用2个字宽，32位JVM，1个字宽等于4字节
一个字宽存Mark Word,一个字宽存对象指针，如果数组还有一个数组长度
其中Mark Word中存着锁状态，对象的hashCode，对象分带年龄，是否偏向锁，锁标志位

为了减少加锁解锁的消耗，java1.6引入偏向锁和轻量级锁，所以一共有四种状态：无状态锁，偏向锁状态，轻量级锁状态，重量级锁状态
偏向锁（发现很多时候其实不存在多线程竞争，而总是同一个线程获取锁，所以引入了偏向锁）：
基本是说获取锁时检查Mark Word里是否有指向当前线程的偏向锁，如果有则表示已经获取锁了，
如果没有则看Mark Word里的偏向锁状态是否为1，如果是则尝试用CAS把偏向锁指向当前线程，如果为0则用CAS竞争锁
轻量级锁： 先在当前线程中创建用于存储锁记录的空间，并赋值对象头中的Mark Word到该空间，然后尝试用CAS把对象头中的Mark Word替换为指向锁记录的指针

各种锁的比较
偏向锁：加锁解锁不需要额外消耗，几乎和非同步方法执行速度一样；但是如果线程间存在竞争会带了额外撤销锁的花销；适合只有一个线程访问同步块的情况
轻量级锁：线程竞争不会阻塞，提供响应速度；自旋会消耗CPU；适合追求相应时间的情况
重量级锁： 线程竞争会阻塞，不消耗CPU；慢；适合追求吞吐量的情况

3. 原子操作的实现原理
CAS，Compare And Swap，基本思路：一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有才赋成新值，如果发生变化，则不赋值

Java中的原子实现：
Java通过锁和循环CAS实现原子操作
1）JVM用CAS操作实现原子操作，而CAS操作利用了处理器的CMPXCHG指令，即自旋执行CAS直到成功为止，
（AtomicBoolean，AtomicInteger，AtomicLong基于CAS）

CAS的三个问题：
a.ABA问题
如果一个值原来是A，变成了B，又变成了A，用CAS检查则没有发生变化，但实际发生了变化.
ABA解决办法是版本号，每次更新时把版本号加1如A-B-A成1A-2B-3A
java 1.5开始Atomic包提供了AtomicStampedReference来解决ABA问题
b.循环时间长开销大
c.只能保证一个共享变量的原子操作，这时可以用锁
2）锁实现原子操作
这个好理解，获取锁然后再操作，不会有同步问题，锁有偏向锁，轻量级锁，重量级锁，其中前两个也是基于CAS，所以CAS是一个并发的核心理念


第三章 Java内存模型
1. Java内存模型的基础
线程之间通信机制有两种：共享内存和消息传递
Java用的是共享内存，Java线程之间的通信是透明的

