第一章 了解SQL
理解数据库最简单的办法是将其想象成一个文件柜，数据库是一种保存有组织数据的容器
数据库管理系统，DBMS，可以创建和操作数据库，你并不直接访问数据库，而是使用DBMS，替你访问数据库，不要混淆数据库和数据库管理系统，MySQL是一个关系型数据库管理系统

表是一种结构化文件，类似于文件柜中的文件
表由一个或多个列组成，列（column）表中的一个字段，每个列都有数据类型（datatype）限制该列存储的数据
行（row）表中的一个记录

主键（primary key）一列（或一组列），它的值能区分表中的每行，虽然并不总是需要主键，但是应该保证每个表具有一个主键，以便于操纵和管理。
任何列都可以作为主键，只要满足以下两个条件：任意两行都不具有相同的主键值；每行都必须具有一个主键值（主键值不允许为NULL）
主键通常定义在表的一列上，也可以用多个列作为主键，在使用多列作为主键时，所有列值得组合必须是唯一的（单列的值可以不唯一）
主键的最好习惯：不更新主键列中的值，不重用主键列中的值，不在主键中用可能会更改的值。（注：一般是ID为主键，符合所有要求）

SQL是专门用于与数据库通信的语言


第二章 MySQL简介
MySql是一种DBMS，C/S结构的数据库，Client用于提交请求，Server负责处理请求（增删改查）
mysql --help获取各种用法
连接mysql -u ben -p -h myserver -P 9999

其他图形界面client： MySQL Administrator， MySQL Query Browser


第三章 使用MySQL
连接需要主机名（本地为localhost），端口，用户名，密码
(关键字大写，这样有助于阅读)

可用的数据库列表
SHOW DATABASES;

用crashcourse数据库
USE crashcourse;

显示数据库内的可用的列表
SHOW TABLES;

显示表中的列的详细信息，对各个字段返回一行，行中包含字段名，数据类型，是否允许为NULL，键信息，默认值，其他信息（如auto_inrement）
SHOW COLUMNS FROM customers;
某些表列需要唯一值，比如订单号，而且自增，这样可以在CREATE表时包含该关键字

SHOW COLUMNS的快捷方式
DSCRIBE customers;

其他SHOW
SHOW STATUS，用于显示服务器状态信息
SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句
SHOW GRANTS,用来显示用户的安装权限
SHOW ERRORS和SHOW WARNINGS，用来显示错误和警告信息

HELP SHOW，显示允许的SHOW语句


第四章 检索数据
SELECT prod_name
FROM products;
从表中查询列，注意如果在不同的电脑上可能结果不同，因为如果没有明确查询结果，则返回的数据的顺序没有特殊意义，返回的数据可能是数据被添加到表中的顺序，也可能不是，只要返回相同数目的行，就是正常的
多条SQL必须加分号，但单条有的可以不加，但事实上总是加上分号是没坏处的
SQL不区分大小写，但是所有列和表明使用小写，所有关键字大写，这样易读
处理SQL时，所有空格都会被忽略，所以可以一行也可以多行，多行容易阅读
(例子中的所有SQL都是分行的，基本是以FROM等关键字分割的)

检索多个列
SELECT prod_id, prod_name, prod_price
FROM products;
SQL查询结果一般是无格式的数据，比如9，实际上是9块钱，但钱的符号不会存在数据库里，都是应用程序取出来再处理的

显示所有列
SELECT *
FROM products;
一般除非真的需要每个列，否则*会降低性能，通配符可以检索出名字未知的列

检索不同的行
SELECT DISTINCT vend_id
FROM products;
注意DISTINCT必须在列前面，只显示不同的行，去重，DISTINCT对所有列有限，而不仅是最前面的列，SELECT DISTINCT vend_id, prod_price;除非两列都不同，否则将显示所有行

限制结果
SELECT prod_name
FROM products
LIMIT 5;
返回不多于5行，为了获取下一个5行，可指定开始行和行数
SELECT prod_name
FROM products
LIMIT 5,5;
注意：检索出来的第一行为行0而不是1，LIMIT 1,1结果是第二行
行数不够时有多少返回多少
LIMIT 4 OFFSET 3（易读）是从第三行起曲四行，等价于LIMIT 3,4

使用完全限定的表名
完全限定的名字来引用列，同时使用表名和列
SELECT products.prod_name
FROM products;

SELECT products.prod_name
FROM crashcourse.products;
限定数据库的表
这种写法在某些情形有用，后面会介绍


第五章 排序检索数据
检索出的结果一般和表中顺序一致，但更新或删除过，则顺序会受到影响
SELECT prod_name
FROM products
ORDER BY prod_name;
对prod_name列以字母顺序排序
注：一般ORDER BY的列是显示所选择的列，但实际中用非检索的列排序是完全合法的

按多个列排序
检索3个列，按其中两个列对结果进行排序，首先按价格，再按名称排序
SELECT prod_id, prod_price, prod_name
FROM products
ORDER BY prod_price, prod_name;
如果多行具有相同的prod_price时，再按prod_name排序，如果prod_price没有重复的值，则不会按prod_name排，这点要注意

指定排序方向
降序DESC
SELECT prod_id, prod_price, prod_name
FROM products
ORDER BY prod_price DESC;

SELECT prod_id, prod_price, prod_name
FROM products
ORDER BY prod_price DESC, prod_name;
这个语句只会对prod_price进行DESC，prod_name在每个相同的价格内还是按升序
如果想在多列上降序排序，不许对每个列都指定DESC关键字
ASC是升序，但是一般不用因为默认是升序
如果要区分大小写排序，默认不区分大小写，ORDER BY语句做不到，只能改数据库配置

ORDER BY与LIMIT组合找出最值
SELECT prod_price
FROM products
ORDER BY prod_price DESC
LIMIT 1
返回最贵的
注：OERDER BY子句必须位于FROM子句后面，LIMIT必须位于ORDER BY后面，否则结果有问题


第六章 过滤数据
WHERE子句
WHERE可以指定搜索条件，WHERE子句在FROM之后
SELECT prod_name, prod_price
FROM products
WHERE prod_price = 2.50;
在同时用ORDER BY和WHERE时，ORDER BY位于WHERE之后（注：可以想，必须先知道顺序才能LIMIT，如果要知道顺序，必须知道排列的集合，要知道排列的集合，则必须知道筛选条件WHERE，而WHERE切都必须依赖于SELECT）

WHERE子句
=	等于
<>	不等于
!=	不等于
<	>	<=	>=
BETWEEN	在两个值之间

SELECT prod_name, prod_price
FROM products
WHERE prod_name = 'fuses'
不区分大小写，Fuses和fuses相同

SELECT prod_name, prod_price
FOMR products
WHERE prod_price <= 10;
搜索小于等于10块钱的物品

SELECT vend_id, prod_name
FROM products
WHERE vend_id <> 1003;
还可用!=
列出不是供应商ID为1003制造的产品

注：单引号用来限定字符串，如果将值与字符串比较，则需要限定单引号，用来与数字比较则不用

SELECT prod_name, prod_price
FOMR products
WHERE prod_price BETWEEN 5 AND 10;
注：匹配BETWEEN必须用AND，而且结果包括5和10

SELECT prod_name
FROM products
WHERE prod_price IS NULL;
空值查找
查找电子邮件为空的客户
SELECT cust_id
FROM customers
WHERE cust_email IS NULL;


第七章 数据过滤
AND操作符
SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1003 AND prod_price <= 10;
如果有多个条件则每多一个加一个AND

OR操作符
SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1002 OR vend_id = 1003;
多一个条件加一个OR

AND优先于OR
SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price >= 10;
结果是返回vend_id为1002或1003并且大于等于10，即>=10只对1003起作用，因为AND的优先于OR
圆括号可以解决优先级问题
SELECT prod_id, prod_price, prod_name
FROM products
WHERE （vend_id = 1002 OR vend_id = 1003） AND prod_price >= 10;
注：任何涉及优先级的时候都必须用圆括号，增加可读性

IN操作符
SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002, 1003)
ORDER BY prod_name;
检索供应商ID为1002和1003的所有产品，IN后面跟由都喊分割的清单，整个清单都必须包括在圆括号中，IN和OR等价
用IN不用OR因为：IN语法清楚，IN比OR更快，IN的最大优点是可以包含其他SELECT语句，后面会介绍

NOT操作符
SELECT prod_name, prod_price
FROM products
WHERE vend_id NOT IN (1002, 1003)
ORDER BY prod_name;
用来否定后面的操作符
NOT支持对BETWEEN,IN,EXISTS否定


第八章 用通配符进行过滤
LIKE操作符
%表示任何字符出现任意次数
SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE'jet%';
结果：
prod_id prod_name
JP100	JetPack 1000
JP200	JetPack 2000
jet之后任意字符，不管有多少，搜索可以区分大小写(配置MySQL)，若区分大写，jet%与JetPack 100将不匹配

SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE'%anvi%';
结果
prod_id prod_name
ANVO1	.5 ton anvil
ANVO2	1 ton anvil
%anvi%任何包含anvi的字符串而不管它前面和后面，通配符可以在任何位置使用任意次，也可以用在中间（一般不怎么会放在中间）
注意： %通配符不能匹配NULL， WHERE prod_name LIKE '%'找不出NULL的行
末尾空格会干扰通配符，如anvil尾部有一个空格，则WHERE prod_name LIKE '%anvi'匹配不到它们，解决办法是在后面加一个%，或者更好的方法用函数去掉首尾空格

下划线通配符
匹配任意单个字符，与%类似
SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE'_ ton anvil';
.5 ton anvil不会匹配到，因为_只匹配单个字符

通配符使用技巧
不要过度使用通配符，如果其他操作能达到目的，尽量用其他操作
在确实需要用通配符时，除非绝对需要，否则不要把它们用在搜索的开始出，把通配符放在起始处会很慢
注意通配符的位置，大部分应该是在首尾


第九章 用正则表达式进行搜索
基本字符匹配
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '1000'
ORDER BY prod_name
匹配包含1000的所有prod_name，注意与LIKE的区别，如果prod_name是JA 1000，正则表达式会返回，LIKE不会，因为LIKE是匹配整个列，LIKE ‘1000’只能匹配1000，不能匹配JA 1000，这是正则表达式和LIKE的一个重要区别
默认正则表达式匹配不区分大小写，如果需要区分则用BINARY，如WHERE prod_name REGEXP BINARY 'JA .000'

OR
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '1000|2000'
ORDER BY prod_name
两个以上就是1000|2000|3000

匹配字符之一
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '[123] Ton'
ORDER BY prod_name;
[123]是匹配1或2或3，可匹配1 ton, 2 ton, 3 ton
可以把[]理解成OR的另一种形式
[123]Ton 等价于 [1|2|3]Ton,但是必须用[]
SELECT prod_id, prod_name
FROM products
WHERE prod_name REGEXP '1|2|3 Ton'
ORDER BY prod_name;
匹配结果是
1 ton anvil
2 ton anvil
JetPack 1000
因为不加括号的意思是1或2或3 Ton，除非把|放在集合中，否则就是对整个字符串或
[^123]匹配这些字符之外的任何东西

匹配范围
[12345]为了简化一般用-代表一个范围
[0-9] [a-z]
SELECT prod_name
FROM products
WHERE prod_name REGEXP '[1-5] Ton'
ORDER BY prod_name
结果：
.5 ton anvil
1 ton anvil
...
注意.5也可以匹配，因为正则表达式会匹配在其中的意思，而不是LIKE匹配整个，.5 ton anvil包含[1-5] Ton，
不用写.[1-5] Ton*，MySQL中的正则表达式和正常语言中的稍有不同

匹配特殊字符
反斜杠，\,一个不行，需要两个\\,因为MySQL自己解释一个，另一个给正则表达式（其实Java也是这样）
SELECT prod_name
FROM products
WHERE prod_name REGEXP '.'
ORDER BY prod_name
所有非空大于等于一个字符的都显示出来了，注意MySql正则的特殊，是包含关系，REGEXP后面的只要包含在结果里就能匹配
SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\.'
ORDER BY prod_name
有点的匹配到，必须用两个反斜杠
特殊字符|,[]等都必须这样，如果匹配反斜杠则\\\
\\n 换行
\\t 制表
\\r 回车
'\r' 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；
'\n' 换行，换到当前位置的下一行，而不会回到行首

[:alnum:]数字和字母，[:alpha:]任意字母
还有很多其他的，用时可以查

*	0或多个
+	1或多个
?	0或1个
{n}	匹配n次
{n,}匹配不少于n次
{n,m}匹配范围，m不超过255

匹配多个实例
SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\([0-9] sticks?\\)'
ORDER BY prod_name;
结果：
TNT (1 stick)
TNT (5 sticks)
\\匹配括号，转义，0-9匹配数字，?匹配0或1个字符

SELECT prod_name
FROM products
WHERE prod_name REGEXP '[[:digit:]]{4}'
ORDER BY prod_name;
匹配连续4个数字，[:digit:]匹配单个数字，由于是集合，{4}匹配次数，所以[[:digit:]]{4}
注意正则表达式通常有多种写法，上面还可以写成'[0-9][0-9][0-9][0-9]'
(注解：如果比较高级的写法不会的话，就用清楚的写法，比如[0-9][0-9][0-9][0-9]，或[0-9]{4},[[]]双括号，可能比较不好想)

定位符
^	文本的开始
$	文本的结尾
[[:<:]]	词的开始
[[:>:]]	词的结尾
搜索小数点开始的数字，用[0-9\\.]不行，必须用^
SELECT prod_name
FROM products
WHERE prod_name REGEXP '^[0-9\\.]'
ORDER BY prod_name;
搜索0-9或.开始的，而不是0-9接着. 因为[]表示一个集合

注意^在集合中的意思是否定该集合，[^0-3],否则意思为字符串的开始处
LIKE和REGEXP不同在于，LIKE匹配整个串二REGEXP匹配子串，利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样
用SELECT来测试正则表达式（不用数据库）
SELECT 'hello' REGEXp '[0-9]'; 返回0，因为不匹配，如果匹配返回1，这个可以检查正则表达能不能用，先检查再用比较好


第十章 创建计算字段
数据库表中的数据一般不是想要的格式，比如，实际中想要公司名加逗号加公司ID，这时需要直接从数据中检索，然后转换
字段基本上与列的意思一样，只不过表中称列，在计算中一般称字段
很多转格式工作在Client也可以完成，不过一般都会让服务器完成，因为DBMS优化过，处理这些更快

拼接字段
concatenate，拼接，把值拼接到一起构成单个值

SELECT Concat(vend_name, '(', vend_country, ')')
FROM vendors
ORDER BY vend_name;
结果：
Concat(vend_name, '(', vend_country, ')')
ACME (USA)
Jouets Et (France)
注意：很多DBMS会用+或||实现拼接，Mysql则是用Concat()函数，这点要记住
Concat()把多个串连接起来形成一个长串，Concat()需要一个或多个指定的串，用逗号分隔

删除右侧多余空格
SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')')
FROM vendors
ORDER BY vend_name;
RTrim()函数去掉值右边的所有空格，还支持LTrim()清除左边的空格，Trim清楚左右的空格

别名
前面的例子中，Concat后的字段不好查询，可以起一个alias来替换，用关键字AS
SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS
vend_titile
FROM vendors
ORDER BY vend_name;
结果：
vend_titile
ACME (USA)
Jouets Et (France)
现在，列名为vend_title，可以按这个名字引用此列
别名还有其他用途，包括对列表名含有不符合规定的字符，如空格，对其重命名，或在原来名字起的不好时重新扩充

SELECT prod_id, quantity, item_price,
	quantity*item_price AS expanded_price
FROM orderitems
WHERE order-num = 20005;
检索结果计算(支持加减乘除)，新列命名，结果
prod_id quantity item_price expanded_price
...

测试： SELECT 2*3；返回6
SELECT Trim(' abc ');返回abc
SELECT Now(); 返回当前时间
用SELECT可以在不用数据库的情况下测试，防止错误，和上一章类似


第十一章 使用数据处理函数
SQL一般支持如下函数：
处理文本，比如删除，大小写转换
算数，比如加减乘除，绝对值
日期时间，比如两日期之差
DBMS信息，比如用户登录信息，版本信息

文本处理函数
Upper函数,转大写
SELECT vend_name, Upper(vend_name) AS vend_name_upcase
FROM vendors
ORDER BY vend_name;
结果
vend_name 	vend_name_upcase
...

常用的文本处理函数
Left()	返回串左边的字符
Length()	返回串的长度
Locate()	返回串的一个子串
Lower()	返回串的小写形式
LTrim()	去掉左边空格
Right()	返回串右边的字符
RTrim()	去掉串右边的空格
Soundex()	返回串的Soundex模式，SOUNDEX(str)从str返回一个soundex字符串。两个字符串应该有几乎是相同的同音字符串
SubString()	返回子串
Upper()	转换为大写形式

SELECT cust_name, cust_contact
FROMｃｕｓｔｏｍｅｒｓ
ＷＨＥＲＥ　Ｓｏｕｎｄｅｘ（ｃｕｓｔ_contact) = Soundex('Y Lie');
结果
cust_name cust_contact
Coyote		Y Lee
Lee不是Lie，但是发音类似，所以可以搜索，注意函数的用法，这些函数就像加减乘除一样，可以在任意地方使用

日期和时间
AddDate()	增加一个日期（天，周等），注意日期是2015-01-01，不是时间，10:11:01
AddTime()	增加一个时间（时，分）
CurDate()	返回当前日期
CurTime()	返回当前时间
Date()		返回日期时间的日期部分，比如2015-01-01 10:11:01返回2015-01-01
DateDiff()	就是两个日期之差
Date_Add()	日期运算函数
Date_Format()	返回一个格式化的日期时间字符串
Day()	返回一个日期的天数部分
DayOfWeek()	传入一个日期，返回星期几
Hour()	返回一个时间的小时部分
Minute()	返回一个时间的分钟部分
Month()	返回一个时间的月部分
Now()	返回当前日期和时间
Second()	返回一个时间的秒部分
Time()	返回一个日期时间的的数据部分
Year()	返回一个日期的年部分

如果用日期则必须用四位数的年，虽然79,81可以被解析为1979等，但是不好
SELECT cuts_id, order_num
FROM orders
WHERE order_date = '2005-09-01';
其实这种写法不太好，如果订单是2005-09-01 11:09:01就匹配不到，所以不要这么写，之所以写在这是当反例的

SELECT cuts_id, order_num
FROM orders
WHERE Date(order_date) = '2005-09-01';
如果比较日期，用Date，这样拿出日期部分，忽略时间，可以直接用=比较，后面直接写成'xxxx-xx-xx'，即使数据库表的格式是datetime
类似还有Time(order_date)

SELECT cuts_id, order_num
FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
可用，但是不好，用下面的

SELECT cuts_id, order_num
FROM orders
WHERE Year(order_date) = 2005 AND Month(order_date) = 9;
注：要优先用函数来操作，而不是直接比较，取出时直接用函数操作后再进行比较

数字处理函数
Abs（）	返回绝对值
Exp指数， Mod求余 Rand随机


第十二章 汇总数据
AVG 平均， COUNT 行数， MAX 最大值， MIN 最小， SUM 和，所有参数都是某列，注意函数的参数一般是列名，包括其他函数，文本处理，时间函数等

SELECT AVG(prod_price) AS avg_price
FROM products;
返回所有产品的平均价格

SELECT AVG(prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
具体某个提供商的平均价格
AVG()只能用于一个列的平均，列名为参数，如果需要获得多个列则需要多个AVG，AVG会忽略值是NULL的行

SELECT COUNT(*) AS num_cust
FROM customers;
查询表中客户的总数

SELECT COUNT(cust_email) AS num_cust
FROM customers;
有email的客户总数
如果指定列名，则其中值为NULL的会忽略，如果COUNT(*)则不会忽略NULL,所以上面那个可以查所有用户个数，而下面这个只能查有email

SELECT MAX(prod_price) AS max_price
FROM products;
最贵的产品，MAX通常用于查找数值和时间，但是也可以查找其他的，比如字符串，不过不常用，MAX会忽略NULL

MIN与MAX用法一样，只不过意思相反

SELECT SUM(quantity) AS items_ordered
FROM orderitems
WHERE order_num = 2005;
返回订单号为2005的物品数量之和
SUM可以进行数值计算，忽略NULL行
SELECT SUM(item_price*quantity) AS total_price
FROM orderitems
WHERE order_num = 2005;
注意这个把item_price和quantity都select出来了，然后做运算，SUM可以选择多行做运算

SELECT AVG(DISTINCT prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
只筛选不同的做平均，默认是ALL，所有的都算，不用写明
DISTINCT只能用于具体行，不能用于*和运算，比如COUNT(DISTINCT *)不合法，必须COUNT(DISTINCT col_name)
理论上可以用于MAX和MIN，不过没有意义

组合
SELECT COUNT(*) AS num_items,
	MIN(prod_price) AS price_min,
	MAX(prod_price) AS price_max,
	AVG(prod_price) AS price_avg
FROM products;
结果
num_items price_min price_max price_avg
...
这个例子用于把表的各种指数筛选出来，还用了各种函数，注意别名的用法，这种时候不要用原来的列名，因为会引起歧义，这就是别名的用处
注：务必使用函数，这些SQL内置函数都是专业优化过的，效率高，易读，不出错


第十三章 数据分组
分组允许把数据分成多个组，以便对每个组进行计算
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id
结果
vend_id	num_prods
1001	3
1002	2
...
可以理解为：对不同vend_id分别进行COUNT(*)，分组其实就是把函数精确化到以某个列作为区分，比如各国人口，就是country这个列进行GROUP BY，然后COUNT（num）
注意GROUP BY会只是Mysql分组数据，然后对每个组使用函数，如COUNT，而不是对整个结果使用
SELECT出vend_id才可能用GROUP BY，不能没SELECT vend_id而用GROUP BY vend_id，还有AS是针对一个的，如只针对COUNT(*),如果vend_id需要，则再加一个AS，vend_id AS xxx

GROUP BY注意事项：
1.GROUP BY子句可以包含任意数目的列，这就能对分组进行嵌套
2.如果在GROUP BY子句中嵌套分组，数据会在最后规定的分组上汇总，建立分组时，指定的所有列都一起计算（没太明白，可以试试）
3.GROUP BY子句中的每个列都必须是检索列（SELECT出来的）或有效表达式（不能是聚集函数，这个可以理解，因为如果是COUNT之类的函数，那就没法GROUP BY了，GROUP BY必须根据数据库中的表中的原始数据进行，而不是中间数据），如果SELECT用了表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名（同样的原因，别名没在表的原始数据中，它只是个中间结果）
4.除了聚集计算语句，SELECT语句中的每个列都必须在GROUP BY子句中给出
5.如果分组有多个NULL，则NULL将作为一个分组返回（分组就是GROUP BY时某列具有相同值的行组成的一个组）
6.GROUP BY子句必须出现在WHERE子句后面，ORDER BY子句前面（好理解，只有分好组才能排序）

WITH ROLLUP可以得到每个分组的级别值（不太清楚，可以试试）
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id WITH ROLLUP;

过滤分组
HAVING，与WHRER乐死，所有的WHERE子句都可以用HAVING代替，唯一的差别就是WHERE过滤行，HAVING过滤分组，所以GROUP BY的结果再进行限定，比如订单大于两个的用户，就用HAVING，而不能用WHERE
SELECT cust_id, COUNT(*) AS orders
FROM orders
GROUP BY cust_id
HAVING COUNT(*) > 2;
对cust_id进行分组之后再进行COUNT(*)操作算出各个分组的订单数，之后再对分组的结果进行筛选，HAVING和WHERE唯一别是HAVING针对分组，如果这里用WHERE则不起作用，因为WHERE针对行

HAVING和WHERE区别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤，WHERE排除的行不包括在分组中，HAVING子句基于WHERE排除后形成的分组进行过滤
SELECT vend_id, COUNT(*) AS num_prods
FROM products
WHERE prod_price >= 10
GROUP BY vend_id
HAVING COUNT(*) >= 2;
列出含有2个及以上，价格大于等于10的产品供应商，价格大于10显然是对于原始数据的，行，所以用WHERE，提供两个以上商品的则需要GROUP BY，GROUP BY vend_id,基于COUNT(*),正是因为基于COUNT(*)所以才能用HAVING COUNT(*) >= 2过滤
如果不加WHERE过滤则全部原始数据都参加分组，WHERE针对原始数据过滤，HAVING基于分组（注：估计由于原始数据也是一种分组，即每个一组，所以HAVING可以代替WHERE）

分组和排序
GROUP BY和ORDER BY虽然有时能完成相同的工作，但是两者实际不同
GROUP BY                                                             ORDER BY
分组，单输出可能不是分组的顺序（可能不按序输出）                          按序
只能用SELECT出的列或SELECT的表达式列（正则筛选的列）                     任意列，可以ORDER BY没SELECT的列，还可以是别名
如果与聚集函数一起使用列，如COUNT(*)，则必须使用                         不一定用（可以理解为不关心是否使用了函数）
可以理解为由于ORDER BY本身就是对中间数据排序，所以不关心原始数据
使用GROUP BY时，同时要使用ORDER BY，保证顺序，GROUP BY不保证顺序（虽然一般按序，但是特殊情况不会，需要ORDER BY保障）

SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING SUM(quantity*item_price) >= 50;

SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING SUM(quantity*item_price) >= 50
ORDER BY ordertotal;
注：HAVING的筛选基本上一定是基于函数的，即SELECT的函数，GROUP BY 是基于SELECT里没有用函数的列，ORDER BY什么也不基于，随便哪一列都行，虽然如此但是还是最好基于SELECT里的列，可读性好的多

子句顺序
子句        说明                              是否必须使用
SELECT      要返回的列或表达式                 是
FROM        从中SELECT数据的表                 仅在需要从表中查询数据时
WHERE       行级别过滤                         否
GROUP BY    根据什么分组                       仅在按组计算时用
HAVING      组级别过滤                         否
ORDER BY    排序                               否
LIMIT       限制检索的行数                      否


第十四章 使用子查询
利用子查询进行过滤
跨表查询，即一个表的查询结果是另一个语句的数据范围，一个组合
SELECT cust_id
FROM orders
WHERE order_num IN (SELECT order_num
					FROM　orderitems
					WHERE prod_id = 'TNT2');

子查询总是从内向外处理，实际上执行了两个操作，首先查询子查询，返回结果以列表形式返回，这时外部变成IN(result from subSelect)

SELECT cust_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
				  FROM orders
				  WHERE order_num IN (SELECT order_num
				  					  FROM orderitems
				  					  WHERE prod_id = 'TNT2'));
检索订购TNT2的客户信息，基于客户ID，而客户ID由基于子查询
注意：子查询可读性较差，适当的缩进换行可以提高可读性
还有如果是多行的话，WHERE需要注意,WHERE子句中列数和子查询返回的列数相同才行，一对一
一般子查询都用IN，也可以用=，<>等

计算字段子查询
从customers表中检索客户列表，对于检索出的每个客户，统计其在orders表中的订单数目
SELECT cust_name,
	   cust_state,
	   (SELECT COUNT(*)
	    FROM orders
	    WHERE orders.cust_id = customers.cust_id) AS orders
FROM customers
ORDER BY cust_name;
结果：
cust_name cust_state orders
...
注意：子查询别名，子查询作为SELECT的一列，
orders.cust_id = customers.cust_id的意思是比较两个表中的字段，如果不限定就默认在orders表中对比，自己和自己比，所以需要限定，很重要

子查询的构建方式：用渐进测试来构建子查询，先建立和测试最内层的查询，然后用hard code数据建立和测试外城查询，并且再确认它正常工作后才嵌入子查询，在测试，这样做可以避免一下子写出来出了错，难以debug的情况


第十五章 联结（join）表
关系表
两张表通过主键关联
物品的信息和生产商的信息需要分别存在两张表里，因为如果放在一张表里的话，有大量重复，很多商品都是一个生产商提供的，在关系数据库里，大量的重复绝不是一件好事，若有大量重复，则必须把重复部分分成另一张表

供应商和商品分别存在两张表里的坏处（反过来就是分表的好处）
很多商品的供应商都是一样的，大量重复存储浪费空间
如果供应商信息改变，需要改动地方太多
大量重复数据有不一致的可能（人为的输错）

vendors表存储供应商，每个供应商占一行，用ID表示（主键），products表只存储产品信息，它除了存储供应商ID（vendors表的主键）之外，不存储其他任何供应商的信息
vendors的主键叫做products表的外键，它可以关联两个表，外键是表中的某一列，它包含另一个表的主键值，连接两张表，外键是个很重要的概念

可伸缩性：能不断适应增加的工作量，关系数据库的适应性优于非关系数据库

数据存在多个表中需要用联结来查询
联结，用来在一条SELECT语句中关联表
重要的是，需要理解联结不是物理实体，它在数据库表中不存在，它存在于查询执行当中
为了防止非法数据，即products里的供应商在vendors里查不到的情况，用指定主键和外键实现（这就是维护引用完整性）

创建联结
SELECT vend_name, prod_name, prod_price
FROM vendors, products
WHERE vendors.vend_id = products.vend_id
ORDER BY vend_name, prod_name;
注：prod_name，prod_price（这两个在同一个表）和vend_name不在一个表中，FROM有两个表，就是联结的两个表，这两个表通过WHERE联结，其中需要指定表明，vendors.vend_id = products.vend_id，这点一定要注意
联结实际上是将第一个表中的每一行与第二个表中的每一行对比，WHERE是行的过滤
没有联结（WHERE）的结果是表1和表2的笛卡尔积，即第一个表中的行数乘以第二个表中的行数
注意：不能忘记WHERE，否则结果就是笛卡尔积

内部联结
基于两个表之间的联结称内部联结或等值联结，可以用下面的语法
INNER JOIN两张表，ON表示条件（和WHERE相同，推荐用这种语法，更清晰说明用了联结，有时还能提高效率）
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id = products.vend_id;

联结多张表（用AND）
SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems, products, vendors
WHERE products.vend_id = vendors.vend_id
	AND orderitems.prod_id = products.prod_id
	AND order_num = 20005;
注意FROM和WHERE，WHERE中的表必须在FROM中。
显示20005订单的商品，订单存在orderitems表中，这些商品通过供应商ID联结到vendors表中相应的供应商，最后一个条件是过滤订单号，WHERE不光是联结，还可以通过AND增加行过滤条件，比如AND order_num = 20005
注：能不用联结多张表就不用，因为联结越多效率越低

SELECT cust_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
				  FROM orders
				  WHERE order_num IN (SELECT order_num
				  					  FROM orderitems
				  					  WHERE prod_id = 'TNT2'));
这个例子可以用联结
SELECT cust_name, cust_contact
FROM customers, orders, orderitems
WHERE customers.cust_id = orders.cust_id
	AND orderitems.order_num = orders.order_num
	AND prod_id = 'TNT2';
SELECT后面的行可以是包含在FROM表中的任何行，WHERE中的表也必须在FROM表里

注：一般一个操作可以用不止一种方法实现，但是性能会有差异，所以有必要对各种机制实验，找到合适的方法


第十六章 创建高级联结
使用表别名
除了可以给列起别名，还可以给表起别名，主要是因为：缩短SQL长度，允许单条SELECT语句中多次使用相同的表
SELECT cust_name, cust_contact
FROM customers AS c, orders AS o, orderitems AS oi
WHERE c.cust_id = o.cust_id
	AND oi.order_num = o.order_num
	AND prod_id = 'TNT2';
注意表别名不仅可以用于WHERE子句，还可以用于SELECT，ORDER BY等其他部分，表别名只在查询执行中时用，并不会显示在查询结果中，这与列别名不一样

使用不同类型的联结
自联结
如果查到某生产商的DTNTR商品有问题，想查下该生产商的其他商品：
SELECT prod_id, prod_name
FROM products
WHERE vend_id = (SELECT vend_id
				 FROM products
				 WHERE prod_id = 'DTNTR');
注意IN往往是外面那个与内部中的SELECT一样，如vend_id = (SELECT vend_id，都是vend_di
联结：
SELECT p1.prod_id, p1.prod_name
FROM products AS p1, products AS p2
WHERE p1.vend_id = p2.vend_id
	AND p2.prod_id = 'DTNTR';
注意，表别名的使用，查询中需要的两个表其实是同一张表，FROM中出现了两次，虽然合法，但有歧义，所以要把该表和自己联结，查找（有些不容易理解，弄不清就用IN，正确优先）
还有自联结的效率有时优于子查询，所以试一下两种方法，看哪个快

自然联结
自然联结是只能选择那些唯一的列，排除多次出现，每个列只显示一次
一般通过SELECT *通配符对其他表的列使用明确的子集来完成
SELECT c.*, o.order_num, o.order_date,
		oi.prod_id, oi_quantity, OI.item_price
FROM customers AS c, orders AS o, orderitems AS oi
WHERE c.cust_id = o.cust_id
	AND oi.order_num = o.order_num
	AND prod_id = 'FB';
这里通配符只对第一个表用，其他表用具体列（可以理解为自然联结就是普通联结，多个表，选择列，显示那些列）
注：联结的基本语法：
SELECT col1, col2, ...(来自不同的表)
FROM table1， table2, ...
WHERE table1.xxx=table2.xxx AND xxx AND xxx="";
等价于
SELECT col1 FROM　ｔａｂｌｅ１　ＷＨＥＲＥ　xxx IN(SELECT xxx FROM table2 WHERE xxx)




