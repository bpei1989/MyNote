第一章 MyBatis入门
1.1 Mybatis是什么
MyBatis是一个简化和实现了java数据持久化层的开源框架，它抽象了大量的JDBC冗余代码，并提供了一个简单易用的API和数据库交互
MyBatis通过抽象底层的JDBC代码，自动化SQL结果集产生Java对象，Java对象的数据持久化数据库过程使得对SQL的使用变得容易

1.2 为什么选择MyBatis
JDBC操作有大量重复代码，创建联结，创建Statement对象，设置输入参数，释放资源
MyBatis简化了上述任务，如准备需要执行的SQL statement对象并将Java对象作为输入数据传递给statement对象的任务，开发人员可以专注于逻辑

(1)表
CREATE TABLE STUDENTS
(
	stud_id int(11) NOT NULL AUTO_INCREMENT,
	name varchar(50) NOT NULL,
	email varchar(50) NOT NULL,
	dob date DEFAULT NULL,
	PRIMARY KEY (stud_id)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=gbk;
INSERT INTO students(stud_id, name, email, dob)
values (1, 'Student1', 'student1@gmail.com', '1983-06-25');
INSERT INTO students(stud_id, name, email, dob)
values (2, 'Student2', 'student2@gmail.com', '1983-06-25');

(2)pom
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
    
    <dependency>
  	  <groupId>org.mybatis</groupId>
  	  <artifactId>mybatis</artifactId>
  	  <version>3.2.2</version>
  	</dependency>
  	
  	<dependency>
  	  <groupId>mysql</groupId>
  	  <artifactId>mysql-connector-java</artifactId>
  	  <version>5.1.22</version>
  	  <scope>runtime</scope>
  	</dependency>
  	
  	<dependency>
  	   <groupId>org.slf4j</groupId>
  	   <artifactId>slf4j-api</artifactId>
  	   <version>1.7.5</version>
  	</dependency>

  	<dependency>
  	   <groupId>org.slf4j</groupId>
  	   <artifactId>slf4j-log4j12</artifactId>
  	   <version>1.7.5</version>
  	   <scope>runtime</scope>
  	</dependency>
  	
  	<dependency>
  	   <groupId>log4j</groupId>
  	   <artifactId>log4j</artifactId>
  	   <version>1.2.17</version>
  	   <scope>runtime</scope>
  	</dependency>
  </dependencies>  

(3)Log配置（文件路径放到classpath里）
log4j.rootLogger=DEBUG, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.patternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%-5p] %c - %m%n

(4)mybatis-config.xml和映射器StudentMapper.xml配置文件
mybatis-config.xml(数据库连接信息，类别名等，加到classpath中)
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <typeAliases>
    <typeAlias alias="Student" type="com.mybatis3.domain.Student" />
  </typeAliases>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC" />
      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.jdbc.Driver" />
        <property name="url" value="jdbc:mysql://localhost:3360/test />
        <property name="username" value="root" />
        <property name="password" value="admin" />
      </dataSource>
    </environment>
  </environments>
  <mappers>
    <mapper resource="com/mybatis3/mappers/StudentMapper.xml" />
  </mapper>
</configuration>

StudentMapper.xml(放到com.mybatis3.mapper包中)
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<mapper namespace="com.mybatis3.mappers.StudentMapper">
  <resultMap type="Student" id="StudentResult">
    <id property="studId" column="stud_id" />
    <result property="name" column="name" />
    <result property="email" column="email" />
    <result proerty="dob" column="dob" />
  </resultMap>
  <select id="findAllStudents" resultMap="StudentResult">
    SELECT * FROM STUDENTS
  </select>
  <insert id="insertStudent" parameterType="Student">
    INSERT INTO STUDENT(STUD_ID,NAME,EMAIL,DOB)
        VALUES(#{studId},#{name},#{email},#{dob})
  </insert>
</mapper>

(5) 创建MyBatisSqlSessionFactory单例类（实例化，使它持有一个SqlSessionFactory对象,可获取SqlSession对象和执行映射Sql语句）
package com.mybatis3.util;
import java.io.*;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.*;
public class MyBatisSqlSessionFactory
{
	private static SqlSessionFactory sqlSessionFactory;
	public static SqlSessionFactory getSqlSessionFactory() {
		if(sqlSessionFactory == null) {
			InputStream inputStream;
			try {
				InputStream = Resources.getResourcesAsStream("mybatis-config.xml");
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
			} catch (IOException e) {
				throw new RuntimeException(e.getCause());
			}
		}
		return sqlSessionFactory;
	}

	public static SqlSession openSession() {
		return getSqlSessionFactory().openSession();
	}
}

（6） 创建StudentMapper接口和StudentService类
StudentMapper接口，定义的属性名和在MapperXML中定义的SQL映射语句名称相同
package com.mybatis3.util;
import java.util.Date;
public class Student {
	private Integer studId;
	private String name;
	private String email;
	private Date dob;
	// setter & getter
	/*和下面的名称相同
  <resultMap type="Student" id="StudentResult">
    <id property="studId" column="stud_id" />
    <result property="name" column="name" />
    <result property="email" column="email" />
    <result proerty="dob" column="dob" />
  </resultMap>
	*/
}

创建Mapper接口和StudentMapper.java其方法和StudentMapper.xml中的名称相同
package com.mybatis3.mappers;
import java.util.List;
import com.mybatis3.domain.Student;
public interface StudentMapper {
	List<Student> findAllStudents();
	Student finStudentById(Integer id);
	void insertStudent(Student student);
/*
  <select id="findAllStudents" resultMap="StudentResult">
    SELECT * FROM STUDENTS
  </select>
  <insert id="insertStudent" parameterType="Student">
    INSERT INTO STUDENT(STUD_ID,NAME,EMAIL,DOB)
        VALUES(#{studId},#{name},#{email},#{dob})
  </insert>
 */
}

StudentService.java对表STUDENTS操作
package com.mybatis3.services;
import java.util.List;
import org.apache.ibatis.session.SqlSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.mybatis3.domain.Student;
import com.mybatis3.mapper.StudentMapper;
import com.mybatis3.util.MyBatisSqlSessionFactory;
public class StudentService {
	private Logger logger = LoggerFactory.getLogger(getClass());
	public List<Student> findAllStudents() {
		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
		try {
			StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
			return studentMapper.findAllStudents();
		} finally {
			sqlSession.close(); //必须close，否则session不会释放
		}
	}

	public Student findStudentById(Integer studId) {
		logger.debug("Select Student By ID: {}", studId);
		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
		try {
			StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
			return studentMapper.findStudentById(studId);
		} finally {
			sqlSession.close();
		}
	}

	public void createStudent(Student student) {
		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
		try {
			StudentMapper.studentMapper = sqlSession.getMapper(StudentMapper.class);
			studentMapper.insertStudent(student);
			sqlSession.commit();
		} finally {
			sqlSession.close();
		}
	}
}

还可以不通过Mapper接口
Student student = (Student)sqlSession.selectOne("com.mybatis3.mappers.StudentMapper.findStudentById", studId);
不过一般不会这么写，知道这个原理就好，其实是通过直接指定方法，而不是通过Mapper反射到类，在从类执行方法

基本工作流程： 首先配置MyBatis配置文件mybatis-config.xml，包含JDBC连接参数，配置映射器Mapper XML配置文件，其中包含SQL语句映射。
然后，用mybatis-config.xml的信息创建了SqlSessionFactory对象，每个数据库应该就一个SqlSessionFactory对象实例，所以用了单例模式。
创建一个映射器Mapper接口StudentMapper，方法名和StudentMapper.xml中定义的id值完全一样，注意StudentMapper.xml中namespce的值被设置成com.mybatis3.mappers.StudentMapper,是StudentMapper接口的名字，这样就可以用这个接口调用映射的SQL。
在StudentService.java中，在每一方法中创建了一个新的SqlSession，并在方法功能完成后关闭，每一个线程都应该有自己的SqlSession实例，SqlSession对象不是线程安全的，所以不能共享，SqlSession的作用域最好就是其方法的作用域，比如request作用域


第二章 引导MyBatis
1. 使用XML配置MyBatis
构建SqlSessionFactory最常见的方式是基于XML配置，下面的mybatis-config.xml是一个典型的MyBatis配置
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <properties resource="application.properties">
    <property name="username" value="db_user" />
    <property name="password" value="verysecurepwd" />
  </properties>

  <settings>
  	<setting name="cacheEnable" value="true">
  </settings>

  <typeAliases>
    <typeAlias alias="Tutor" type="com.mybatis3.domain.Tutor" />
    <package name="com.mybatis3.domain" />
  </typeAliases>

  <typeHandlers>
    <typeHandler handler="com.mybatis3.typehandlers.PhoneTypeHandler" />
    <package nae="com.mybatis3.typehandlers" />
  </typeHandlers>

  <environments default="development">
    <environment id="development">
      <transcationManager type="JDBC" />
      <dataSource type="POOLED">
        <property name="driver" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </dataSource>
    </environment>
    <environment id="production">
      <transcationManager type="MANAGED" />
      <dataSource type="JNDI">
        <property name="data_source" value="java:comp/jdbc/MyBatisDemoDS" />
      </dataSource>
    </environment>
  </environments>

  <mappers>
    <mapper resource="com/mybatis3/mappers/StudentMapper.xml">
    <mapper url="file:///D:/mybatisdemo/mappers/TutorMapper.xml" />
    <mapper class="com.mybatis3.mappers.TutorMapper" />
  </mappers>
</configuration>

（1）最重要的部分，MyBatis支持多个dataSource环境，DEV开发，TEST测试，QA质量评估，UAT验收，PRODUCTION生产，可以通过environment id设置
本xml默认环境被设置成development，当需要部署到生产服务器时，则只需要把默认环境改成生产环境，改environment id属性
如果需要多个数据库，如一个用于存购物车，一个用于存订单，则需要连接多个数据库，则每个数据库配置成独立环境，并且为每个数据库创建一个SqlSessionFactory，对每个environment，需要配置dataSource和transactionManager，如：
<environments default="shoppingcart">
  <environment id="shoppingcart">
   <transactionManager type="MANAGED" />
    <dataSource type="JNDI">
      <property name="data_source" value="java:comp/jdbc/ShoppingcartDS" />
    </dataSource> 
  </environment>
  <environment id="reports">
    <transactionManager type="MANAGED" />
    <dataSource type="JNDI">
      <property name="data_source" value="java:comp/jdbc/ReportsDS" />
    </dataSource>
  </environment>
</environments>
为每个环境创建一个SqlSessionFactory
inputStream = Resources.getResourceAsStream("mybatis-config.xml");
defaultSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
cartSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "shoppingcart");
reportSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "reports");
创建SqlSessionFactory时，如果没有指定，则用默认的（第一个）
注：注意id与代码中的映射，还有dataSource，transactionManager

（2）数据源DataSource
      <dataSource type="POOLED">
        <property name="driver" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </dataSource>
dataSource可以配置为： UNPOOLED，POOLED，JNDI
UNPOOLED，MyBatis为每个数据库操作创建一个新的连接，并关闭，只用于小规模用户系统
POOLED，MyBatis会创建一个数据库连接池，需要时从池中取出连接，一旦数据库操作完成就会返回给连接池，开发测试环境中一般用这个
JNDI，MyBatis从在应用服务器向配置好的JNDI数据源dataSource获取数据库连接，生产环境一般用这个

（3）事务管理器TransactionManager
负责提交、回退等，可设置为JDBC，MANAGED
JDBC，用JdbcTransactionFactory类创建TransactionManager，如部署到Tomcat中的程序，需要自己管理事务
MANAGED，用ManagedTransactionFactory类创建事务管理器，如一个JavaEE程序部署到JBOSS服务器，会用EJB进行事务管理，Managed是托管，应用本身不去管理事务，而是把事务管理交给应用所在的服务器管理。

（4）Properties，配置属性可以具体化到一个文件中，比如这里是application.properties
而且如果文件中的key和property name一样，则文件中的会覆盖xml中的，一般都是用一个文件
#application.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatisdemo
jdbc.username=root
jdbc.password=admin
文件中的会覆盖xml中的，即username password是root admin，不是db_user， verysecurepwd

还可以在mybatis-config.xml中，使用application.properties文件中的占位符
      <dataSource type="POOLED">
        <property name="driver" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </dataSource>
${jdbc.xxx}需要和文件中的key一样的名字

（5）类型别名
在SQLMapper配置文件中，对于resultType和parameterType属性值，需要使用JavaBean的完全限定名
<select id="findStudentById" parameterType="int" 
	resultType="com.mybatis3.domain.StudentResult">
    SELECT STUD_ID AS ID, NAME, EMAIL, DOB
    FROM STUDENTS WHERE STUD_ID=#{Id}
</select>
<update id="updateStudent" parameterType="com.mybatis3.domain.Student">
	UPDATE STUDENTS
		SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}
		WHERE STUD_DI=#{id}
</upddate>

resultTYpe和parameterType为Student类型的完全限定名，可以起一个别名，然后用到的地方直接用别名
<typeAliases>
  <typeAlias alias="Student" type="com.mybatis3.domain.Student" />
  <typeAlias alias="Tutor" type="com.mybatis3.domain.Tutor" />
  <package name="com.mybatis3.domain" />
</typeAliases>

在SQLMapper中使用别名
<select id="findStudentById" parameterType="int" 
	resultType="StudentResult">
    SELECT STUD_ID AS ID, NAME, EMAIL, DOB
    FROM STUDENTS WHERE STUD_ID=#{Id}
</select>
<update id="updateStudent" parameterType="Student">
	UPDATE STUDENTS
		SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}
	WHERE STUD_DI=#{id}
</upddate>

可以不为每一个JavaBean单独定义别名，可以提供需要取别名的JavaBean所在的包，MyBatis会自动扫描包内定义的JavaBeans，然后分别为
JavaBean注册一个小写字母开头的别名
<typeAliases>
  <package name="com.mybatis3.domain" />
</typeAliases>

如果Student.java和Tutor.java定义在com.mybatis3.domain中，则会被注册为student,tutor

注解@Alias可以覆盖xml别名
@Alias("StudentAlias")
public class Student {

}

（6）类型处理器typeHandlers
MyBatis会对基本类型，基本数据类型，基本类型的包裹类型，byte，java.util.Date, java.sql.Date, java.sql.Time, java.sql.Timestamp,枚举等类型使用内建的类型处理器
当属性的类型属于上述类型，则会使用对应的类型处理器把值设置到PrparedStetement中，类似，从SQL结果也有类似过程
<insert id="insertStudent" parameterType="Student">
  INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB)
  VALUES(#{studId},#{name},#{email},#{dob})
</insert>
处理过程如下：
a）创建一个有占位符的PreparedStatement接口
PreparedStatement pstmt = connection.prepareStatement ("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)");
b）检查Student对象属性studId类型，然后用适合的setXXX方法
pstmt.setInt(1,student.getStudId());
c）类似的对其他的也是调用setXXX方法
pstmt.setString(2, student.getName());
pstmt.setString(3, student.getEmail());
d)对dob对采用setDate，尔地阿尔会转换java.util.Date为java.sql.Timestamp
pstmt.setTimestamp(4, new Timestamp((student.getDob()). getTime()));

MyBatis通过类型处理器来鉴别类型调用set方法

如果一个自定义类型，则需要用自定义的类型处理器
Student有个phoneNumber属性，它是一个类，比如
public class PhoneNumber {
 private String countryCode;
 private String stateCode;
 private String number;
 ...
}
<insert id="insertStudent" parameterType="Student">
 insert into students(name,email,phone)
 values(#{name},#{email},#{phone}) 
</insert>
默认typeHandler无法处理，则写一个自定义的，MyBatis提供了抽象类BaseTypeHandler<T>,可以继承此类创建自定义型处理器。 
packagecom.mybatis3.typehandlers; 
importjava.sql.CallableStatement; 
importjava.sql.PreparedStatement; 
importjava.sql.ResultSet; 
importjava.sql.SQLException; 
importorg.apache.ibatis.type.BaseTypeHandler; 
importorg.apache.ibatis.type.JdbcType; 
importcom.mybatis3.domain.PhoneNumber;
//注意需要重载几个方法，就这么写，一般都是转字符串，这里是把phoneNumber转为字符串
public class PhoneTypeHandler extends BaseTypeHandler<PhoneNumber> {
	@Override
	public void setNonNullParameter(PreparedStatement ps, int i, PhoneNumber parameter, 
		JdbcType jdbcType) throws SQLException {
		ps.setString(i, parameter.getAsString());
	}

	@Override
	public void getNullableResult(ResultSet rs, String columnName)
	 throws SQLException {
	 	return new PhoneNumber(rs.getString(columnName));
	}

	@Override
	public PhoneNumber getNullableResult(ResultSet rs, int columnIndex)
	 throws SQLException {
	 	return new PhoneNumber(rs.getString(columnIndex));
	}

	@Override
	public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex)
	 throws SQLException {
	 	return new PhoneNumber(cs.getString(columnIndex)); } }
	 }
}
一旦我们实现了自定义的类型处理器，需要注册在mybatis-config.xml中
<configuration>
 <properties resource="application.properties" />
 <typeHandlers>
  <typeHandler handler="com.mybatis3.typehandlers. PhoneTypeHandler" />
 </typeHandlers>
</configuration>

（6）全局设置
  <settings>
  	<setting name="cacheEnable" value="true">
  </settings>
特定的设置覆盖默认的全局设置，有很多，用到时查
<settings> 
	<setting name="cacheEnabled" value="true" /> 
	<setting name="lazyLoadingEnabled" value="true" /> 
	<setting name="multipleResultSetsEnabled" value="true" /> 
	<setting name="useColumnLabel" value="true" /> 
	<setting name="useGeneratedKeys" value="false" /> 
	<setting name="autoMappingBehavior" value="PARTIAL" /> 
	<setting name="defaultExecutorType" value="SIMPLE" /> 
	<setting name="defaultStatementTimeout" value="25000" /> 
	<setting name="safeRowBoundsEnabled" value="false" /> 
	<setting name="mapUnderscoreToCamelCase" value="false" />
	<setting name="localCacheScope" value="SESSION" /> 
	<setting name="jdbcTypeForNull" value="OTHER" /> 
	<setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode ,toString" /> 
</settings>

（7）SQL映射Mappers
SQL Mapper文件位置
<mappers>
   <mapper resource="com/mybatis3/mappers/StudentMapper.xml" />
   <mapper url="file:///D:/mybatisdemo/app/mappers/TutorMapper.xml" />
   <mapper class="com.mybatis3.mappers.TutorMapper" />
   <package name="com.mybatis3.mappers" />
</mappers>
以上每一个mapper标签都可以从不同类型的资源中加载mapper文件，应该是用一个就行
resource，指定在classpath中的mapper文件
url，完整文件路径或url
class，指定一个mapper接口
package，指定一个可以找到Mapper接口的包

2. 使用Java API配置MyBatis
各个部分与xml一样，不过用API配置，不常用，不用看

3. 自定义MyBatis日志（不重要，一般用默认的就行）
MyBatis有一个默认日志打印包选择列表，比如slf4j最优先，jdk最后；用org.apache.ibatis.logging.LogFactory.usexxx()可以指定用哪个


第三章 使用XML配置SQL映射器
与Hibernate不同，MyBatis可以直接使用数据库，而不是隐藏，这样可以发挥SQL的威力，MyBatis还消除了冗余代码，更方便使用SQL，代码里直接嵌套SQL不易维护，所以MyBatis使用映射配置文件或注解来配置SQL

1. 映射器配置文件和映射器接口
StudentMapper.xml中id为findStudentById的SQL语句
<?xml version="1.0" encoding="utf-8"?> 
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
<mapper namespace="com.mybatis3.mappers.StudentMapper"> 
  <select id="findStudentById" parameterType="int" resultType="Student"> 
    select stud_id as studId, name, email, dob 
    from Students where stud_id=#{studId} 
  </select> 
</mapper>

Java Code
可以直接用Student student = sqlSession.selectOne("com.mybatis3.mappers.StudentMapper.findStudentById", studId);
但是这样不好，需要自己找和保证各种条件，不会用，但是知道这个原理，可以直接找到方法，然后传入参数调用
//正确做法，新建一个名字一样的接口
//StudentMapper.xml所在的包名是com.mybatis3.mappers,对应的接口就是com.mybatis3.mappers.StudentMapper,方法名也必须和XML中一样
//因为是要根据反射获取对象和方法，所以必须一致，否则就找不到了
package com.mybatis3.mappers; 
public interface StudentMapper
{
  Student findStudentById(Integer id);
}
在Student.xml配置文件中，namespace和StudentMapper的接口需要一致，而且id，parameterType,returnType和接口中的方法名，参数类型，返回值一致
所有的操作都是类似，如insert等
public Student findStudentById(Integer studId) {
  SqlSession sqlSession = MyBatisUtil.getSqlSession();
  try {
    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
    return studentMapper.findStudentById(studId);
  } finally { 
    sqlSession.close();
  }
}
如果Mapper接口中的方法和XML中的语句不匹配，会抛出异常，实际上，parameterType是可选的，反射机制会决定parameterType，但是从可读性角度来看，必须指定，如果parameterType没有指定，则调用者必须保证类型

2.映射语句
变量用#{}，名字也要和java中的一样
(1)INSERT
<!--id对方法，parameterType对参数，必须与接口中一样，最上层还有namespace，是接口的报名.接口名，反射时会用-->
<insert id="insertStudent" parameterType="Student">
    INSERT INTO STUDNETS(STUD_ID,NAME,EMAIL,PHONE)
    	VALUES（#{studId},#{name},#{email},#{phone})
</insert>
parameterType用的别名，否则应该是这个类的完整路径
int count = sqlSession.insert("com.mybatis3.mappers.StudentMapper.insertStudent", student);
一般不会这么用
//正确用法
package com.mybatis3.mappers; 
public interface StudentMapper
{
  Student findStudentById(Integer id);
  int insertStudent(Student student);
}
然后调用
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
int count = mapper.insertStudent(student);

自动生成主键
userGenerateKeys让数据库生产AUTO_INCREMENT，keyProperty把这个属性赋予某一列
<insert id="insertStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="studId">
    INSERT INTO STUDNETS(STUD_ID,NAME,EMAIL,PHONE)
    	VALUES（#{studId},#{name},#{email},#{phone})
</insert>
stud_id自动生成，并设置到student对象的studId上
<selectKey>可以生成主键，order是触发器的前后
<insert id="insertStudent" parameterType="Student">
<!!--selectKey主键值，keyProperty把主键值赋给谁，resultType返回类型，order顺序-->
	<selectKey keyProperty="studId" resultType="int" order="BEFORE">
		SELECT primarykey FROM DUAL
	</selectKey>
	INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,PHONE)
		VALUES(#{studId},#{name},#{email},#{phone})
</insert>
在INSERT之前把主键值设置到studId
另一种写法，order类似于触发器
<insert id="insertStudent" parameterType="Student">
	INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,PHONE)
		VALUES(#{studId},#{name},#{email},#{phone})
	<selectKey keyProperty="studId" resultType="int" order="AFTER">
		SELECT primarykey FROM DUAL
	</selectKey>
</insert>

(2)UPDATE
<update id="updateStudent" parameterType="Student">
	UPDATE STUDENTS SET NAME=#{name}, EMAIL=#{email}, PHONE=#{phone}
	WHERE STUD_ID=#{studId}
</update>
//不常用
int noOfRowsUpdated = sqlSession.update("com.mybatis3.mappers.StudentMapper.updateStudent", student);
//正确
package com.mybatis3.mappers; 
public interface StudentMapper
{
  Student findStudentById(Integer id);
  int insertStudent(Student student);
  int updateStudent(Student student);
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);//接口反射
int noOfRowsUpdated = mapper.updateStudent(student);

(3)DELETE
<delete id="deleteStudent" parameterType="int">
	DELETE FROM STUDENTS WHERE STUD_ID=#{studId}
</delete>
//不常用
int studId = 1;
int noOfRowsDeleted = sqlSession.delete("com.mybatis3.mappers.StudentMapper.deleteStudent", studId);
//正确
public interface StudentMapper
{
  Student findStudentById(Integer id);
  int insertStudent(Student student);
  int updateStudent(Student student);
  int deleteStudent(int studId);
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
int noOfRowsDeleted = mapper.deleteStudent(studId);

(4)SELECT
MyBatis真正强大的功能是映射SELECT结果到JavaBean方面的灵活性
<select id="findStudentById" parameterType="int"
resultType="Student">
	SELECT STUD_ID, NAME, EMAIL, PHONE 
	FROM STUDENTS 
	WHERE STUD_ID=#{studId}
</select>
调用java后Student类的studId没有填充，因为MyBatis只负责填充与列名相同的部分，比如name,email,phone，如果不同则不会填充
SELECT STUD_ID, NAME, EMAIL, PHONE，
Student里STUD_ID是studId，而其他的都一样，只不过大小写不一样，不区分大小写
解决方法：别名
<select id="findStudentById" parameterType="int"
resultType="Student">
	SELECT STUD_ID AS studId, NAME, EMAIL, PHONE 
	FROM STUDENTS 
	WHERE STUD_ID=#{studId}
</select>
public interface StudentMapper{
	...
	Student findStudentById(Integer studId);
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
Student student = mapper.findStudentById(studId);
(不要这么写，虽然能工作
int studId =1;
Student student = sqlSession.selectOne("com.mybatis3.mappers. StudentMapper.findStudentById", studId);
)

<select id="findAllStudents" resultType="Student">
	SELECT STUD_ID AS studId, NAME,EMAIL, PHONE 
	FROM STUDENTS
</select>
List<Student> students = sqlSession.selectList("com.mybatis3.mappers.StudentMapper.findAllStudents");
或
package com.mybatis3.mappers; 
public interface StudentMapper { 
  List<Student> findAllStudents();
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
List<Student> students = mapper.findAllStudents();
List<Student>其实也可以用Set Map
对于List,Collection,Iterable类型，MyBatis会返回java.util.ArrayList
对于Map类型，返回HashMap
对于SortedSet，返回TreeSet

3.结果集映射为ResultMap
ResultMap用来将SELECT结果映射到JavaBean属性
(1)简单ResultMap

