第一章 MyBatis入门
1.1 Mybatis是什么
MyBatis是一个简化和实现了java数据持久化层的开源框架，它抽象了大量的JDBC冗余代码，并提供了一个简单易用的API和数据库交互
MyBatis通过抽象底层的JDBC代码，自动化SQL结果集产生Java对象，Java对象的数据持久化数据库过程使得对SQL的使用变得容易

1.2 为什么选择MyBatis
JDBC操作有大量重复代码，创建联结，创建Statement对象，设置输入参数，释放资源
MyBatis简化了上述任务，如准备需要执行的SQL statement对象并将Java对象作为输入数据传递给statement对象的任务，开发人员可以专注于逻辑

(1)表
CREATE TABLE STUDENTS
(
	stud_id int(11) NOT NULL AUTO_INCREMENT,
	name varchar(50) NOT NULL,
	email varchar(50) NOT NULL,
	dob date DEFAULT NULL,
	PRIMARY KEY (stud_id)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=gbk;
INSERT INTO students(stud_id, name, email, dob)
values (1, 'Student1', 'student1@gmail.com', '1983-06-25');
INSERT INTO students(stud_id, name, email, dob)
values (2, 'Student2', 'student2@gmail.com', '1983-06-25');

(2)pom
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
    
    <dependency>
  	  <groupId>org.mybatis</groupId>
  	  <artifactId>mybatis</artifactId>
  	  <version>3.2.2</version>
  	</dependency>
  	
  	<dependency>
  	  <groupId>mysql</groupId>
  	  <artifactId>mysql-connector-java</artifactId>
  	  <version>5.1.22</version>
  	  <scope>runtime</scope>
  	</dependency>
  	
  	<dependency>
  	   <groupId>org.slf4j</groupId>
  	   <artifactId>slf4j-api</artifactId>
  	   <version>1.7.5</version>
  	</dependency>

  	<dependency>
  	   <groupId>org.slf4j</groupId>
  	   <artifactId>slf4j-log4j12</artifactId>
  	   <version>1.7.5</version>
  	   <scope>runtime</scope>
  	</dependency>
  	
  	<dependency>
  	   <groupId>log4j</groupId>
  	   <artifactId>log4j</artifactId>
  	   <version>1.2.17</version>
  	   <scope>runtime</scope>
  	</dependency>
  </dependencies>  

(3)Log配置（文件路径放到classpath里）
log4j.rootLogger=DEBUG, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.patternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%-5p] %c - %m%n

(4)mybatis-config.xml和映射器StudentMapper.xml配置文件
mybatis-config.xml(数据库连接信息，类别名等，加到classpath中)
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <typeAliases>
    <typeAlias alias="Student" type="com.mybatis3.domain.Student" />
  </typeAliases>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC" />
      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.jdbc.Driver" />
        <property name="url" value="jdbc:mysql://localhost:3360/test />
        <property name="username" value="root" />
        <property name="password" value="admin" />
      </dataSource>
    </environment>
  </environments>
  <mappers>
    <mapper resource="com/mybatis3/mappers/StudentMapper.xml" />
  </mapper>
</configuration>

StudentMapper.xml(放到com.mybatis3.mapper包中)
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<mapper namespace="com.mybatis3.mappers.StudentMapper">
  <resultMap type="Student" id="StudentResult">
    <id property="studId" column="stud_id" />
    <result property="name" column="name" />
    <result property="email" column="email" />
    <result proerty="dob" column="dob" />
  </resultMap>
  <select id="findAllStudents" resultMap="StudentResult">
    SELECT * FROM STUDENTS
  </select>
  <insert id="insertStudent" parameterType="Student">
    INSERT INTO STUDENT(STUD_ID,NAME,EMAIL,DOB)
        VALUES(#{studId},#{name},#{email},#{dob})
  </insert>
</mapper>

(5) 创建MyBatisSqlSessionFactory单例类（实例化，使它持有一个SqlSessionFactory对象,可获取SqlSession对象和执行映射Sql语句）
package com.mybatis3.util;
import java.io.*;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.*;
public class MyBatisSqlSessionFactory
{
	private static SqlSessionFactory sqlSessionFactory;
	public static SqlSessionFactory getSqlSessionFactory() {
		if(sqlSessionFactory == null) {
			InputStream inputStream;
			try {
				InputStream = Resources.getResourcesAsStream("mybatis-config.xml");
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
			} catch (IOException e) {
				throw new RuntimeException(e.getCause());
			}
		}
		return sqlSessionFactory;
	}

	public static SqlSession openSession() {
		return getSqlSessionFactory().openSession();
	}
}

（6） 创建StudentMapper接口和StudentService类
StudentMapper接口，定义的属性名和在MapperXML中定义的SQL映射语句名称相同
package com.mybatis3.util;
import java.util.Date;
public class Student {
	private Integer studId;
	private String name;
	private String email;
	private Date dob;
	// setter & getter
	/*和下面的名称相同
  <resultMap type="Student" id="StudentResult">
    <id property="studId" column="stud_id" />
    <result property="name" column="name" />
    <result property="email" column="email" />
    <result proerty="dob" column="dob" />
  </resultMap>
	*/
}

创建Mapper接口和StudentMapper.java其方法和StudentMapper.xml中的名称相同
package com.mybatis3.mappers;
import java.util.List;
import com.mybatis3.domain.Student;
public interface StudentMapper {
	List<Student> findAllStudents();
	Student finStudentById(Integer id);
	void insertStudent(Student student);
/*
  <select id="findAllStudents" resultMap="StudentResult">
    SELECT * FROM STUDENTS
  </select>
  <insert id="insertStudent" parameterType="Student">
    INSERT INTO STUDENT(STUD_ID,NAME,EMAIL,DOB)
        VALUES(#{studId},#{name},#{email},#{dob})
  </insert>
 */
}

StudentService.java对表STUDENTS操作
package com.mybatis3.services;
import java.util.List;
import org.apache.ibatis.session.SqlSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.mybatis3.domain.Student;
import com.mybatis3.mapper.StudentMapper;
import com.mybatis3.util.MyBatisSqlSessionFactory;
public class StudentService {
	private Logger logger = LoggerFactory.getLogger(getClass());
	public List<Student> findAllStudents() {
		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
		try {
			StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
			return studentMapper.findAllStudents();
		} finally {
			sqlSession.close(); //必须close，否则session不会释放
		}
	}

	public Student findStudentById(Integer studId) {
		logger.debug("Select Student By ID: {}", studId);
		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
		try {
			StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
			return studentMapper.findStudentById(studId);
		} finally {
			sqlSession.close();
		}
	}

	public void createStudent(Student student) {
		SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();
		try {
			StudentMapper.studentMapper = sqlSession.getMapper(StudentMapper.class);
			studentMapper.insertStudent(student);
			sqlSession.commit();
		} finally {
			sqlSession.close();
		}
	}
}

还可以不通过Mapper接口
Student student = (Student)sqlSession.selectOne("com.mybatis3.mappers.StudentMapper.findStudentById", studId);
不过一般不会这么写，知道这个原理就好，其实是通过直接指定方法，而不是通过Mapper反射到类，在从类执行方法

基本工作流程： 首先配置MyBatis配置文件mybatis-config.xml，包含JDBC连接参数，配置映射器Mapper XML配置文件，其中包含SQL语句映射。
然后，用mybatis-config.xml的信息创建了SqlSessionFactory对象，每个数据库应该就一个SqlSessionFactory对象实例，所以用了单例模式。
创建一个映射器Mapper接口StudentMapper，方法名和StudentMapper.xml中定义的id值完全一样，注意StudentMapper.xml中namespce的值被设置成com.mybatis3.mappers.StudentMapper,是StudentMapper接口的名字，这样就可以用这个接口调用映射的SQL。
在StudentService.java中，在每一方法中创建了一个新的SqlSession，并在方法功能完成后关闭，每一个线程都应该有自己的SqlSession实例，SqlSession对象不是线程安全的，所以不能共享，SqlSession的作用域最好就是其方法的作用域，比如request作用域


第二章 引导MyBatis
1. 使用XML配置MyBatis
构建SqlSessionFactory最常见的方式是基于XML配置，下面的mybatis-config.xml是一个典型的MyBatis配置
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <properties resource="application.properties">
    <property name="username" value="db_user" />
    <property name="password" value="verysecurepwd" />
  </properties>

  <settings>
  	<setting name="cacheEnable" value="true">
  </settings>

  <typeAliases>
    <typeAlias alias="Tutor" type="com.mybatis3.domain.Tutor" />
    <package name="com.mybatis3.domain" />
  </typeAliases>

  <typeHandlers>
    <typeHandler handler="com.mybatis3.typehandlers.PhoneTypeHandler" />
    <package nae="com.mybatis3.typehandlers" />
  </typeHandlers>

  <environments default="development">
    <environment id="development">
      <transcationManager type="JDBC" />
      <dataSource type="POOLED">
        <property name="driver" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </dataSource>
    </environment>
    <environment id="production">
      <transcationManager type="MANAGED" />
      <dataSource type="JNDI">
        <property name="data_source" value="java:comp/jdbc/MyBatisDemoDS" />
      </dataSource>
    </environment>
  </environments>

  <mappers>
    <mapper resource="com/mybatis3/mappers/StudentMapper.xml">
    <mapper url="file:///D:/mybatisdemo/mappers/TutorMapper.xml" />
    <mapper class="com.mybatis3.mappers.TutorMapper" />
  </mappers>
</configuration>

（1）最重要的部分，MyBatis支持多个dataSource环境，DEV开发，TEST测试，QA质量评估，UAT验收，PRODUCTION生产，可以通过environment id设置
本xml默认环境被设置成development，当需要部署到生产服务器时，则只需要把默认环境改成生产环境，改environment id属性
如果需要多个数据库，如一个用于存购物车，一个用于存订单，则需要连接多个数据库，则每个数据库配置成独立环境，并且为每个数据库创建一个SqlSessionFactory，对每个environment，需要配置dataSource和transactionManager，如：
<environments default="shoppingcart">
  <environment id="shoppingcart">
   <transactionManager type="MANAGED" />
    <dataSource type="JNDI">
      <property name="data_source" value="java:comp/jdbc/ShoppingcartDS" />
    </dataSource> 
  </environment>
  <environment id="reports">
    <transactionManager type="MANAGED" />
    <dataSource type="JNDI">
      <property name="data_source" value="java:comp/jdbc/ReportsDS" />
    </dataSource>
  </environment>
</environments>
为每个环境创建一个SqlSessionFactory
inputStream = Resources.getResourceAsStream("mybatis-config.xml");
defaultSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
cartSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "shoppingcart");
reportSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "reports");
创建SqlSessionFactory时，如果没有指定，则用默认的（第一个）
注：注意id与代码中的映射，还有dataSource，transactionManager

（2）数据源DataSource
      <dataSource type="POOLED">
        <property name="driver" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </dataSource>
dataSource可以配置为： UNPOOLED，POOLED，JNDI
UNPOOLED，MyBatis为每个数据库操作创建一个新的连接，并关闭，只用于小规模用户系统
POOLED，MyBatis会创建一个数据库连接池，需要时从池中取出连接，一旦数据库操作完成就会返回给连接池，开发测试环境中一般用这个
JNDI，MyBatis从在应用服务器向配置好的JNDI数据源dataSource获取数据库连接，生产环境一般用这个

（3）事务管理器TransactionManager
负责提交、回退等，可设置为JDBC，MANAGED
JDBC，用JdbcTransactionFactory类创建TransactionManager，如部署到Tomcat中的程序，需要自己管理事务
MANAGED，用ManagedTransactionFactory类创建事务管理器，如一个JavaEE程序部署到JBOSS服务器，会用EJB进行事务管理，Managed是托管，应用本身不去管理事务，而是把事务管理交给应用所在的服务器管理。

（4）Properties，配置属性可以具体化到一个文件中，比如这里是application.properties
而且如果文件中的key和property name一样，则文件中的会覆盖xml中的，一般都是用一个文件
#application.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatisdemo
jdbc.username=root
jdbc.password=admin
文件中的会覆盖xml中的，即username password是root admin，不是db_user， verysecurepwd

还可以在mybatis-config.xml中，使用application.properties文件中的占位符
      <dataSource type="POOLED">
        <property name="driver" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </dataSource>
${jdbc.xxx}需要和文件中的key一样的名字

（5）类型别名
在SQLMapper配置文件中，对于resultType和parameterType属性值，需要使用JavaBean的完全限定名
<select id="findStudentById" parameterType="int" 
	resultType="com.mybatis3.domain.StudentResult">
    SELECT STUD_ID AS ID, NAME, EMAIL, DOB
    FROM STUDENTS WHERE STUD_ID=#{Id}
</select>
<update id="updateStudent" parameterType="com.mybatis3.domain.Student">
	UPDATE STUDENTS
		SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}
		WHERE STUD_DI=#{id}
</upddate>

resultTYpe和parameterType为Student类型的完全限定名，可以起一个别名，然后用到的地方直接用别名
<typeAliases>
  <typeAlias alias="Student" type="com.mybatis3.domain.Student" />
  <typeAlias alias="Tutor" type="com.mybatis3.domain.Tutor" />
  <package name="com.mybatis3.domain" />
</typeAliases>

在SQLMapper中使用别名
<select id="findStudentById" parameterType="int" 
	resultType="StudentResult">
    SELECT STUD_ID AS ID, NAME, EMAIL, DOB
    FROM STUDENTS WHERE STUD_ID=#{Id}
</select>
<update id="updateStudent" parameterType="Student">
	UPDATE STUDENTS
		SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}
	WHERE STUD_DI=#{id}
</upddate>

可以不为每一个JavaBean单独定义别名，可以提供需要取别名的JavaBean所在的包，MyBatis会自动扫描包内定义的JavaBeans，然后分别为
JavaBean注册一个小写字母开头的别名
<typeAliases>
  <package name="com.mybatis3.domain" />
</typeAliases>

如果Student.java和Tutor.java定义在com.mybatis3.domain中，则会被注册为student,tutor

注解@Alias可以覆盖xml别名
@Alias("StudentAlias")
public class Student {

}

（6）类型处理器typeHandlers
MyBatis会对基本类型，基本数据类型，基本类型的包裹类型，byte，java.util.Date, java.sql.Date, java.sql.Time, java.sql.Timestamp,枚举等类型使用内建的类型处理器
当属性的类型属于上述类型，则会使用对应的类型处理器把值设置到PrparedStetement中，类似，从SQL结果也有类似过程
<insert id="insertStudent" parameterType="Student">
  INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB)
  VALUES(#{studId},#{name},#{email},#{dob})
</insert>
处理过程如下：
a）创建一个有占位符的PreparedStatement接口
PreparedStatement pstmt = connection.prepareStatement ("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)");
b）检查Student对象属性studId类型，然后用适合的setXXX方法
pstmt.setInt(1,student.getStudId());
c）类似的对其他的也是调用setXXX方法
pstmt.setString(2, student.getName());
pstmt.setString(3, student.getEmail());
d)对dob对采用setDate，尔地阿尔会转换java.util.Date为java.sql.Timestamp
pstmt.setTimestamp(4, new Timestamp((student.getDob()). getTime()));

MyBatis通过类型处理器来鉴别类型调用set方法

如果一个自定义类型，则需要用自定义的类型处理器
Student有个phoneNumber属性，它是一个类，比如
public class PhoneNumber {
 private String countryCode;
 private String stateCode;
 private String number;
 ...
}
<insert id="insertStudent" parameterType="Student">
 insert into students(name,email,phone)
 values(#{name},#{email},#{phone}) 
</insert>
默认typeHandler无法处理，则写一个自定义的，MyBatis提供了抽象类BaseTypeHandler<T>,可以继承此类创建自定义型处理器。 
packagecom.mybatis3.typehandlers; 
importjava.sql.CallableStatement; 
importjava.sql.PreparedStatement; 
importjava.sql.ResultSet; 
importjava.sql.SQLException; 
importorg.apache.ibatis.type.BaseTypeHandler; 
importorg.apache.ibatis.type.JdbcType; 
importcom.mybatis3.domain.PhoneNumber;
//注意需要重载几个方法，就这么写，一般都是转字符串，这里是把phoneNumber转为字符串
public class PhoneTypeHandler extends BaseTypeHandler<PhoneNumber> {
	@Override
	public void setNonNullParameter(PreparedStatement ps, int i, PhoneNumber parameter, 
		JdbcType jdbcType) throws SQLException {
		ps.setString(i, parameter.getAsString());
	}

	@Override
	public void getNullableResult(ResultSet rs, String columnName)
	 throws SQLException {
	 	return new PhoneNumber(rs.getString(columnName));
	}

	@Override
	public PhoneNumber getNullableResult(ResultSet rs, int columnIndex)
	 throws SQLException {
	 	return new PhoneNumber(rs.getString(columnIndex));
	}

	@Override
	public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex)
	 throws SQLException {
	 	return new PhoneNumber(cs.getString(columnIndex)); } }
	 }
}
一旦我们实现了自定义的类型处理器，需要注册在mybatis-config.xml中
<configuration>
 <properties resource="application.properties" />
 <typeHandlers>
  <typeHandler handler="com.mybatis3.typehandlers. PhoneTypeHandler" />
 </typeHandlers>
</configuration>

（6）全局设置
  <settings>
  	<setting name="cacheEnable" value="true">
  </settings>
特定的设置覆盖默认的全局设置，有很多，用到时查
<settings> 
	<setting name="cacheEnabled" value="true" /> 
	<setting name="lazyLoadingEnabled" value="true" /> 
	<setting name="multipleResultSetsEnabled" value="true" /> 
	<setting name="useColumnLabel" value="true" /> 
	<setting name="useGeneratedKeys" value="false" /> 
	<setting name="autoMappingBehavior" value="PARTIAL" /> 
	<setting name="defaultExecutorType" value="SIMPLE" /> 
	<setting name="defaultStatementTimeout" value="25000" /> 
	<setting name="safeRowBoundsEnabled" value="false" /> 
	<setting name="mapUnderscoreToCamelCase" value="false" />
	<setting name="localCacheScope" value="SESSION" /> 
	<setting name="jdbcTypeForNull" value="OTHER" /> 
	<setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode ,toString" /> 
</settings>

（7）SQL映射Mappers
SQL Mapper文件位置
<mappers>
   <mapper resource="com/mybatis3/mappers/StudentMapper.xml" />
   <mapper url="file:///D:/mybatisdemo/app/mappers/TutorMapper.xml" />
   <mapper class="com.mybatis3.mappers.TutorMapper" />
   <package name="com.mybatis3.mappers" />
</mappers>
以上每一个mapper标签都可以从不同类型的资源中加载mapper文件，应该是用一个就行
resource，指定在classpath中的mapper文件
url，完整文件路径或url
class，指定一个mapper接口
package，指定一个可以找到Mapper接口的包

2. 使用Java API配置MyBatis
各个部分与xml一样，不过用API配置，不常用，不用看

3. 自定义MyBatis日志（不重要，一般用默认的就行）
MyBatis有一个默认日志打印包选择列表，比如slf4j最优先，jdk最后；用org.apache.ibatis.logging.LogFactory.usexxx()可以指定用哪个


第三章 使用XML配置SQL映射器
与Hibernate不同，MyBatis可以直接使用数据库，而不是隐藏，这样可以发挥SQL的威力，MyBatis还消除了冗余代码，更方便使用SQL，代码里直接嵌套SQL不易维护，所以MyBatis使用映射配置文件或注解来配置SQL

1. 映射器配置文件和映射器接口
StudentMapper.xml中id为findStudentById的SQL语句
<?xml version="1.0" encoding="utf-8"?> 
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
<mapper namespace="com.mybatis3.mappers.StudentMapper"> 
  <select id="findStudentById" parameterType="int" resultType="Student"> 
    select stud_id as studId, name, email, dob 
    from Students where stud_id=#{studId} 
  </select> 
</mapper>

Java Code
可以直接用Student student = sqlSession.selectOne("com.mybatis3.mappers.StudentMapper.findStudentById", studId);
但是这样不好，需要自己找和保证各种条件，不会用，但是知道这个原理，可以直接找到方法，然后传入参数调用
//正确做法，新建一个名字一样的接口
//StudentMapper.xml所在的包名是com.mybatis3.mappers,对应的接口就是com.mybatis3.mappers.StudentMapper,方法名也必须和XML中一样
//因为是要根据反射获取对象和方法，所以必须一致，否则就找不到了
package com.mybatis3.mappers; 
public interface StudentMapper
{
  Student findStudentById(Integer id);
}
在Student.xml配置文件中，namespace和StudentMapper的接口需要一致，而且id，parameterType,returnType和接口中的方法名，参数类型，返回值一致
所有的操作都是类似，如insert等
public Student findStudentById(Integer studId) {
  SqlSession sqlSession = MyBatisUtil.getSqlSession();
  try {
    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
    return studentMapper.findStudentById(studId);
  } finally { 
    sqlSession.close();
  }
}
如果Mapper接口中的方法和XML中的语句不匹配，会抛出异常，实际上，parameterType是可选的，反射机制会决定parameterType，但是从可读性角度来看，必须指定，如果parameterType没有指定，则调用者必须保证类型

2.映射语句
变量用#{}，名字也要和java中的一样
(1)INSERT
<!--id对方法，parameterType对参数，必须与接口中一样，最上层还有namespace，是接口的报名.接口名，反射时会用-->
<insert id="insertStudent" parameterType="Student">
    INSERT INTO STUDNETS(STUD_ID,NAME,EMAIL,PHONE)
    	VALUES（#{studId},#{name},#{email},#{phone})
</insert>
parameterType用的别名，否则应该是这个类的完整路径
int count = sqlSession.insert("com.mybatis3.mappers.StudentMapper.insertStudent", student);
一般不会这么用
//正确用法
package com.mybatis3.mappers; 
public interface StudentMapper
{
  Student findStudentById(Integer id);
  int insertStudent(Student student);
}
然后调用
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
int count = mapper.insertStudent(student);

自动生成主键
userGenerateKeys让数据库生产AUTO_INCREMENT，keyProperty把这个属性赋予某一列
<insert id="insertStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="studId">
    INSERT INTO STUDNETS(STUD_ID,NAME,EMAIL,PHONE)
    	VALUES（#{studId},#{name},#{email},#{phone})
</insert>
stud_id自动生成，并设置到student对象的studId上
<selectKey>可以生成主键，order是触发器的前后
<insert id="insertStudent" parameterType="Student">
<!!--selectKey主键值，keyProperty把主键值赋给谁，resultType返回类型，order顺序-->
	<selectKey keyProperty="studId" resultType="int" order="BEFORE">
		SELECT primarykey FROM DUAL
	</selectKey>
	INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,PHONE)
		VALUES(#{studId},#{name},#{email},#{phone})
</insert>
在INSERT之前把主键值设置到studId
另一种写法，order类似于触发器
<insert id="insertStudent" parameterType="Student">
	INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,PHONE)
		VALUES(#{studId},#{name},#{email},#{phone})
	<selectKey keyProperty="studId" resultType="int" order="AFTER">
		SELECT primarykey FROM DUAL
	</selectKey>
</insert>

(2)UPDATE
<update id="updateStudent" parameterType="Student">
	UPDATE STUDENTS SET NAME=#{name}, EMAIL=#{email}, PHONE=#{phone}
	WHERE STUD_ID=#{studId}
</update>
//不常用
int noOfRowsUpdated = sqlSession.update("com.mybatis3.mappers.StudentMapper.updateStudent", student);
//正确
package com.mybatis3.mappers; 
public interface StudentMapper
{
  Student findStudentById(Integer id);
  int insertStudent(Student student);
  int updateStudent(Student student);
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);//接口反射
int noOfRowsUpdated = mapper.updateStudent(student);

(3)DELETE
<delete id="deleteStudent" parameterType="int">
	DELETE FROM STUDENTS WHERE STUD_ID=#{studId}
</delete>
//不常用
int studId = 1;
int noOfRowsDeleted = sqlSession.delete("com.mybatis3.mappers.StudentMapper.deleteStudent", studId);
//正确
public interface StudentMapper
{
  Student findStudentById(Integer id);
  int insertStudent(Student student);
  int updateStudent(Student student);
  int deleteStudent(int studId);
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
int noOfRowsDeleted = mapper.deleteStudent(studId);

(4)SELECT
MyBatis真正强大的功能是映射SELECT结果到JavaBean方面的灵活性
<select id="findStudentById" parameterType="int"
resultType="Student">
	SELECT STUD_ID, NAME, EMAIL, PHONE 
	FROM STUDENTS 
	WHERE STUD_ID=#{studId}
</select>
调用java后Student类的studId没有填充，因为MyBatis只负责填充与列名相同的部分，比如name,email,phone，如果不同则不会填充
SELECT STUD_ID, NAME, EMAIL, PHONE，
Student里STUD_ID是studId，而其他的都一样，只不过大小写不一样，不区分大小写
解决方法：别名
<select id="findStudentById" parameterType="int"
resultType="Student">
	SELECT STUD_ID AS studId, NAME, EMAIL, PHONE 
	FROM STUDENTS 
	WHERE STUD_ID=#{studId}
</select>
public interface StudentMapper{
	...
	Student findStudentById(Integer studId);
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
Student student = mapper.findStudentById(studId);
(不要这么写，虽然能工作
int studId =1;
Student student = sqlSession.selectOne("com.mybatis3.mappers. StudentMapper.findStudentById", studId);
)

<select id="findAllStudents" resultType="Student">
	SELECT STUD_ID AS studId, NAME,EMAIL, PHONE 
	FROM STUDENTS
</select>
List<Student> students = sqlSession.selectList("com.mybatis3.mappers.StudentMapper.findAllStudents");
或
package com.mybatis3.mappers; 
public interface StudentMapper { 
  List<Student> findAllStudents();
}
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
List<Student> students = mapper.findAllStudents();
List<Student>其实也可以用Set Map
对于List,Collection,Iterable类型，MyBatis会返回java.util.ArrayList
对于Map类型，返回HashMap
对于SortedSet，返回TreeSet

3.结果集映射为ResultMap
ResultMap用来将SELECT结果映射到JavaBean属性
(1)简单ResultMap
<resultMap id="StudentResult" type="com.mybatis3.domain.Student">
	<id property="studId" column="stud_id" />
	<result property="name" column="name" />
	<result property="email" column="email" />
	<result property="phone" column="phone" />
</resultMap>
<select id="findAllStudents" resultMap="StudentResult">
	SELECT * FROM STUDENTS
</select>
<select id="findStudentById" parameterType="int" resultMap="StudentResult">
<!--这里studId是上面的id property，数据库中的列名为stud_id-->
	SELECT * FROM STUDENTS WHERE STUD_ID=#{studId}
</select>
resultMap的id是全局唯一的，type必须是与result proerty各个选项对应的那个类或别名
resultType用于基本类型或默认填写的类型，比如各个列与类中的成员变量名一样，而resultMap可把结果映射为JavaBean，即类的各个属性，可以处理列名与类成员变量名不一致的情况
<select id="findAllStudents" resultType="map">
	SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS
</select>
由于结果是map而且多行，就是List<HashMap<String,Object>>
List<HashMap<String, Object>> studentMapList = sqlSession.selectList("com.mybatis3.mappers.StudentMapper.findAllStudents");
for(HashMap<String, Object> studentMap : studentMapList){...}

(2)拓展ResultMap
resultMap可继承，一个resultMap通过extends，可以直接拥有父ResultMap的属性
<resultMap id="StudentResult" type="com.mybatis3.domain.Student">
	<id property="studId" column="stud_id" />
	<result property="name" column="name" />
	<result property="email" column="email" />
	<result property="phone" column="phone" />
</resultMap>

<!--已经拥有上面resultMap的属性-->
<resultMap type="Student" id="StudentWithAddressResult" extends="StudentResult">
	<result property="address.addrId" column="addr_id" />
	<result property="address.city" column="city" />
</resultMap>

(3)联结
可以把两个表的所有列写到一块组成一个ResultMap，只要各个列与SELECT出的结果一一对应就行，比如联结的结果为
表1.列1 表1.列2 表2.列1
那就可以把resultMap写成
<resultMap type="Student" id="StudentWithAddressResult">
	<id property="studId" column="stud_id" />
	<result property="name" column="表1.列1" />
	<result property="email" column="表1.列2" />
	<result property="address.country" column="表2.列1" />
</resultMap>
只要列与外面的类一一对应就行，类不会管查询是联结还是什么，类只管结果
但是一般不会用，因为不清晰，正确做法是：
(注意setter和getter必须有)
public class Address {
 private Integer addrId;
 private String street;
 private String city;
 private String state;
 private String zip;
 private String country;
 // setters & getters
}

public class Student{
	private Integer studId;
	private String name;
	private String email;
	private PhoneNumber phone;
	private Address address; //注意这里，必须是Address类型，才能应对返回的结果
	//setters & getters
}

分两个resultMap，Student包含Address，与逻辑一样，association是has one的意思，而不是把所有的都写到一块
注意id，<id property="studId" column="stud_id" />是与变量对应的，studId与#{studId}，result是结果
<resultMap type="Address" id="AddressResult">
	<id property="addrId" column="addr_id" />
	<result property="street" column="street" />
	<result property="city" column="city" />
	<result property="state" column="state" />
	<result property="zip" column="zip" />
	<result property="country" column="country" />
</resultMap>
<!--type与外面的类名一样，其中的id，result与外面类的属性名和类型一样-->
<resultMap type="Student" id="StudentWithAddressResult">
	<id property="studId" column="stud_id" />
	<result property="name" column="name" />
	<result property="email" column="email" />
	<!--联结的处理，用association关键字，表示外面resultMap包含本ResultMap-->
	<association property="address" resultMap="AddressResult" />
</resultMap>
<!--注意，resultMap只表示结果，xml只规定配置，具体sql语句中的表名，AS等于数据库中一致，与MyBatis的xml无关-->
<select id="findStudentWithAddress" parameterType="int"
resultMap="StudentWithAddressResult">
	SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,
	ZIP, COUNTRY
	FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON
	S.ADDR_ID=A.ADDR_ID
	WHERE STUD_ID=#{studId}
</select>

还可以这么写：
<resultMap type="Student" id="StudentWithAddressResult">
	<id property="studId" column="stud_id" />
	<result property="name" column="name" />
	<result property="email" column="email" />
	<association property="address" javaType="Address">
		<id property="addrId" column="addr_id" />
		<result property="street" column="street" />
		<result property="city" column="city" />
		<result property="state" column="state" />
		<result property="zip" column="zip" />
		<result property="country" column="country" />
	</association>
</resultMap>

(4)嵌套查询（嵌套SELECT会有性能低的问题，所以大型系统一般不会用嵌套查询）
如SELECT xxx WHERE yyy=(SELECT ...), SELECT xxx WHERE yyy IN (SELECT ...)
<resultMap type="Address" id="AddressResult">
	<id property="addrId" column="addr_id" />
	<result property="street" column="street" />
	<result property="city" column="city" />
	<result property="state" column="state" />
	<result property="zip" column="zip" />
	<result property="country" column="country" />
</resultMap>
<select id="findAddressById" parameterType="int"
resultMap="AddressResult">
	SELECT * FROM ADDRESSES WHERE ADDR_ID=#{addrId}
</select>
<resultMap type="Student" id="StudentWithAddressResult">
	<id property="studId" column="stud_id" />
	<result property="name" column="name" />
	<result property="email" column="email" />
	<association property="address" column="addr_id" select="findAddressById" />
</resultMap>
<select id="findStudentWithAddress" parameterType="int"
resultMap="StudentWithAddressResult">
	SELECT * FROM STUDENTS WHERE STUD_ID=#{studId}
</select>
调用：
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
Student student = mapper.findStudentWithAddress(studId);
System.out.println(student);
System.out.println(student.getAddress());

(5)一对多（包含一个集合而不是单个元素的情况）
注：可以执行SQL后看到各列，然后再定义类和XML，在复杂的情况下可能马上不能确定结果，执行SQL根据结果写XML和类
collection标签是指结果是一个集合
联结（嵌套resultMap）：
public class Course { 
	private Integer courseId; 
	private String name; 
	private String description; 
	private Date startDate; 
	private Date endDate; 
	private Integer tutorId; 
	//setters & getters 
}
public class Tutor { 
	private Integer tutorId; 
	private String name; 
	private String email; 
	private Address address; 
	private List<Course> courses; 
	//setters & getters 
}

<resultMap type="Course" id="CourseResult">
	<id column="course_id" property="courseId" />
	<result column="name" property="name" />
	<result column="description" property="description" />
	<result column="start_date" property="startDate" />
	<result column="end_date" property="endDate" />
</resultMap>
<resultMap type="Tutor" id="TutorResult">
	<id column="tutor_id" property="tutorId" />
	<result column="tutor_name" property="name" />
	<result column="email" property="email" />
	<!--collection的属性是resultMap-->
	<collection property="courses" resultMap="CourseResult" />
</resultMap>
<select id="findTutorById" parameterType="int"
resultMap="TutorResult">
<!--这么写不好，分大小写，关键字大写-->
	SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, C.COURSE_ID,
	C.NAME, DESCRIPTION, START_DATE, END_DATE
	FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID=A.ADDR_ID
	LEFT OUTER JOIN COURSES C ON T.TUTOR_ID=C.TUTOR_ID
	WHERE T.TUTOR_ID=#{tutorId}
</select>

嵌套SELECT：
<resultMap type="Course" id="CourseResult">
	<id column="course_id" property="courseId" />
	<result column="name" property="name" />
	<result column="description" property="description" />
	<result column="start_date" property="startDate" />
	<result column="end_date" property="endDate" />
</resultMap>
<resultMap type="Tutor" id="TutorResult">
	<id column="tutor_id" property="tutorId" />
	<result column="tutor_name" property="name" />
	<result column="email" property="email" />
	<association property="address" resultMap="AddressResult" />
	<!--嵌套查询就是最后加一个select指定方法，这个方法返回就是相当于IN (xxx)括号里的部分-->
	<collection property="courses" column="tutor_id" select="findCoursesByTutor" />
</resultMap>
<select id="findTutorById" parameterType="int" resultMap="TutorResult">
	SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL
	FROM TUTORS T WHERE T.TUTOR_ID=#{tutorId}
</select>
<select id="findCoursesByTutor" parameterType="int" resultMap="CourseResult">
	SELECT * FROM COURSES WHERE TUTOR_ID=#{tutorId}
</select>
public interface TutorMapper { 
	Tutor findTutorById(int tutorId); 
} 
TutorMapper mapper = sqlSession.getMapper(TutorMapper.class); 
Tutor tutor = mapper.findTutorById(tutorId); 
System.out.println(tutor); 
List<Course> courses = tutor.getCourses(); 
for (Course course : courses) { System.out.println(course); }

4. 动态SQL
在xml里加上<if>,<choose>,<where>,<foreach>,<trim>，根据条件创建SQL
(1) if
如搜索界面，设置了Tutor，CourseName，StartTime，EndTIme，讲师是必须的，其他可选，则有可能有有可能没有，有的情况下就需要显示特定的过滤结果
<resultMap type="Course" id="CourseResult">
	<id column="course_id" property="courseId" />
	<result column="name" property="name" />
	<result column="description" property="description" />
	<result column="start_date" property="startDate" />
	<result column="end_date" property="endDate" />
</resultMap>
<!--注意参数类型-->
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
	SELECT * FROM COURSES
		WHERE TUTOR_ID= #{tutorId}
	<if test="courseName != null">
	AND NAME LIKE #{courseName}
	</if>
	<if test="startDate != null">
	AND START_DATE >= #{startDate}
	</if>
	<if test="endDate != null">
	AND END_DATE <= #{endDate}
	</if>
</select>

public interface CourseMapper { 
	List<Course> searchCourses(Map<String, Object> map); 
}
public void searchCourses() {
	Map<String, Object> map = new HashMap<String, Object>();
	map.put("tutorId", 1);
	map.put("courseName", "%java%");
	map.put("startDate", new Date());
	CourseMapper mapper = sqlSession.getMapper(CourseMapper.class);
	List<Course> courses = mapper.searchCourses(map);
	for (Course course : courses) { System.out.println(course); }
}
if类似于AND,必须有WHERE的基础上才能只用if，否则需要用<where> <if>

(2) choose, when, otherwise
choose when otherwise类似于if elif else
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
	SELECT * FROM COURSES
	<choose>
		<when test="searchBy == 'Tutor'">
			WHERE TUTOR_ID= #{tutorId}
		</when>
		<when test="searchBy == 'CourseName'">
			WHERE name like #{courseName}
		</when>
		<otherwise>
			WHERE TUTOR start_date >= now()
		</otherwise>
	</choose>
</select>

(3)Where条件
动态插入where条件，if只是where条件的选择类似于动态AND，choose，when，otherwise才是if else，<if>不是
<select id="searchCourses" parameterType="hashmap"
resultMap="CourseResult">
	SELECT * FROM COURSES
	<where>
		<if test=" tutorId != null ">
			TUTOR_ID= #{tutorId}
		</if>
		<if test="courseName != null">
			AND name like #{courseName}
		</if>
		<if test="startDate != null">
			AND start_date >= #{startDate}
		</if>
		<if test="endDate != null">
			AND end_date <= #{endDate}
		</if>
	</where>
</select>

(4)<trim>条件
trim和where类似，不过提供了添加前缀/后缀 或 移除前缀/后缀的功能，更灵活
<select id="searchCourses" parameterType="hashmap"
resultMap="CourseResult">
	SELECT * FROM COURSES
<!--if条件为真则<trim>会插入WHERE，并且移除紧跟WHERE后面的AND或OR-->
<trim prefix="WHERE" prefixOverrides="AND | OR">
<if test=" tutorId != null ">
TUTOR_ID= #{tutorId}
</if>
<if test="courseName != null">
AND name like #{courseName}
</if>
</trim>
</select>

(5)foreach循环（变量一个列表，构造AND，OR或IN）
找到tutor_id为1,3,6的教师的课程，可以传递一个tutor_id列表，遍历列表动态构造SQL语句
<select id="searchCoursesByTutors" parameterType="map"
resultMap="CourseResult">
SELECT * FROM COURSES
<if test="tutorIds != null">
<where>
<!--注意parameterType，这是个很重要部分，类型是MAP，则按map解析，看看传进来的是不是有key为tutorIds，有的话就取出value，与外面类一对一-->
<foreach item="tutorId" collection="tutorIds">
OR tutor_id=#{tutorId}
</foreach>
</where>
</if>
</select>

public interface CourseMapper { 
	List<Course> searchCoursesByTutors(Map<String, Object> map); 
}
public void searchCoursesByTutors() {
	Map<String, Object> map = new HashMap<String, Object>();
	List<Integer> tutorIds = new ArrayList<Integer>();
	tutorIds.add(1);
	tutorIds.add(3);
	tutorIds.add(6);
	map.put("tutorIds", tutorIds);//放到map里，key必须和xml里的名字一样
	CourseMapper mapper = sqlSession.getMapper(CourseMapper.class);
	List<Course> courses = mapper.searchCoursesByTutors(map);//可以自动转换
	for (Course course : courses) { System.out.println(course); }
}

foreach生成IN
<select id="searchCoursesByTutors" parameterType="map" resultMap="CourseResult">
	SELECT * FROM COURSES
	<if test="tutorIds != null">
		<where>
		tutor_id IN
		<!--注意(,)的选项，把结果放到括号，以逗号分割-->
			<foreach item="tutorId" collection="tutorIds"
			open="(" separator="," close=")">
			#{tutorId}
			</foreach>
		</where>
	</if>
</select>

(6)set条件
<update id="updateStudent" parameterType="Student">
	update students
	<set>
	<if test="name != null">name=#{name},</if>
	<if test="email != null">email=#{email},</if>
	<if test="phone != null">phone=#{phone},</if>
	</set>
	where stud_id=#{id}
</update>
if条件返回任何内容，如xxx，set都会插入set xxx，而且会删除末尾的逗号，比如，如果email!=null，set会移除掉email=#{email}后的逗号，生成set phone=#{phone}

5. MyBatis cookbook
(1)枚举
MyBatis可以自动装填枚举类型，用EnumTypeHandler
public enum Gender { FEMALE, MALE }
public class Student {
	private Integer id; 
	private String name; 
	private String email; 
	private PhoneNumber phone; 
	private Address address; 
	private Gender gender; 
	//setters and getters 
}
<insert id="insertStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="id">
 insert into students(name,email,addr_id, phone,gender)
 values(#{name},#{email},#{address.addrId},#{phone},#{gender})
</insert>
执行insertStudent方法时，MyBatis会自动装填枚举名称，MALE，FEMAIL，存到gender列
如果想存储0,1即按序存储则需要妹纸EnumOrdinalTypeHandler，不过一般不会这么用，依赖性高，一旦改了就不适用了，枚举不要依赖下表

(2)BOLB CLOB
CLOB（Character Large Object）
BLOB(binary large object)

CREATE TABLE USER_PICS ( 
	ID INT(11) NOT NULL AUTO_INCREMENT, 
	NAME VARCHAR(50) DEFAULT NULL, PIC BLOB, 
	BIO LONGTEXT, 
	PRIMARY KEY (ID) 
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=LATIN1;

默认MyBatis把CLOB类型列映射到String类型，把BLOB列映射到byte[]类型上
public class UserPic { 
	private int id; 
	private String name; 
	private byte[] pic; 
	private String bio; 
	//setters & getters 
}

<insert id="insertUserPic" parameterType="UserPic">
	INSERT INTO USER_PICS(NAME, PIC,BIO)
	VALUES(#{name},#{pic},#{bio})
</insert>
<select id="getUserPic" parameterType="int" resultType="UserPic">
	SELECT * FROM USER_PICS WHERE ID=#{id}
</select>

public void insertUserPic() {
	byte[] pic = null;
	try {
		File file = new File("C:\\Images\\UserImg.jpg");
		InputStream is = new FileInputStream(file);
		pic = new byte[is.available()];
		is.read(pic);
		is.close();
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
	String name = "UserName";
	String bio = "put some lenghty bio here";
	UserPic userPic = new UserPic(0, name, pic , bio);
	SqlSession sqlSession = MyBatisUtil.openSession();
	try {
		UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class);
		mapper.insertUserPic(userPic);
		sqlSession.commit();
	} finally {
		sqlSession.close();
	}
}

public void getUserPic() {
	UserPic userPic = null;
	SqlSession sqlSession = MyBatisUtil.openSession();
	try {
		UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class);
		userPic = mapper.getUserPic(1);
	} finally {
		sqlSession.close();
	}
	byte[] pic = userPic.getPic();
	try {
		OutputStream os = new FileOutputStream(new File("C:\\Images\\UserImage_FromDB.jpg"));
		os.write(pic);
		os.close();
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
}

(3)传入多个参数
可以用parameterType为map来传入HashMap，还可以直接传入多个参数：
Public interface StudentMapper { 
	List<Student> findAllStudentsByNameEmail(String name, String email); 
}

<select id="findAllStudentsByNameEmail" resultMap="StudentResult">
	select stud_id, name,email, phone from Students
	 where name=#{param1} and email=#{param2}
</select>

StudentMapper studentMapper = sqlSession.getMapper(StudentMapper. class); 
studentMapper.findAllStudentsByNameEmail(name, email);

(4)多行结果映射成Map
多行记录以HashMap存储，使用记录列名为key，记录值为value的形式，可以用selectMap
<select id=" findAllStudents" resultMap="StudentResult">
 select * from Students 
</select>
//studId为key，Student对象为value，即主键为key
Map<Integer, Student> studentMap = sqlSession.selectMap("com.mybatis3.mappers.StudentMapper.findAllStudents", "studId");

(5)RowBounds结果分页
海量数据，分页表示
RowBounds对象用offset和limit参数来构建
每页显示25条记录
<select id="findAllStudents" resultMap="StudentResult">
 select * from Students 
</select>

//第一页，用offset=25，limit=25展示第二页，第三页offset=50,limit=25
int offset =0 , limit =25;
RowBounds rowBounds = new RowBounds(offset, limit); 
List<Student> = studentMapper.getStudents(rowBounds);

(6)使用ResultSetHandler自定义结果集ResultSet处理
自定义查询结果，如stud_id为key，name为value，而不是Student，MyBatis不支持resultMap配置将结果集映射为一个属性为key，其他属性为value，
sqlSession.selectMap()可以返回给定列为key，value为整个对象的结果，但不能一个属性为key，其他属性为value
通过传给sqlSession.select()一个ResultHandler实现，可以实现这个要求
public interface ResultHandler { 
	void handleResult(ResultContext context); 
}

public Map<Integer, String> getStudentIdNameMap() {
	final Map<Integer, String> map = new HashMap<Integer, String>();
	SqlSession sqlSession = MyBatisUtil.openSession();
	try {
		sqlSession.select("com.mybatis3.mappers.StudentMapper.findAllStudents",
			new ResultHandler() {
				@Override
				public void handleResult(ResultContext context) {
					Student student = (Student) context.getResultObject();
					map.put(student.getStudId(), student.getName());
				}
			});
	} finally {
		sqlSession.close();
	}
	return map;
}
通过传给select自定义的ResultHandler可以改变select默认的结果

(7)缓存
应用程序为了提高性能，会把数据控中的数据加载到内存中，MyBatis对映射SELECT语句加载查询结果提供了缓存支持，默认启动一级缓存，如果使用同一个sqlSession接口对象调用了相同的select语句，则直接从缓存中返回，而不用再查一次数据库
可以在SQL映射器XML配置文件中使用<cache />添加全局的二级缓存
添加<cache />后：
所有在映射语句文件中定义的<select>语句查询结果都会被缓存
所有在映射语句文件中定义的<insert>,<update>和<delete>语句将会刷新缓存
缓存根据最近最少被使用算法管理
缓存不支持定时刷新
缓存将存储1024个查询方法返回的列表或对象的引用
缓存会被当做一个读写缓存，即检索出的对象不会被共享，并且可以被调用者安全地修改，不会被其他调用者干扰

可以通过覆盖默认属性来自定义缓存：
<cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true"/>
eviction：缓存移除机制，默认LRU，Least recently used，支持的方式：LRU，FIFO，SOFT（软引用），WEAK（弱引用）
flushInterval:定义缓存刷新间隔，以毫秒计。默认不设置，所以布斯拥刷新间隔，缓存cache只有调用语句的时候刷新
size:缓存中能容纳的最大元素个数，默认1024
readOnly：一个制度的缓存会对所有调用者返回统一实例（实际是返回对象的引用），一个读写缓存将会返回对象的一份拷贝（通过序列化），默认情况下为false

一个缓冲的配置和缓存实例被绑定到映射器配置文件所在的namespace上，所以相同namespace内的所有语句被绑定到一个缓存中
默认映射语句的配置：
<select ... flushCache="false" useCache="true"/> 
<insert ... flushCache="true"/> 
<update ... flushCache="true"/> 
<delete ... flushCache="true"/>
如果需要可以规定特定语句覆盖默认cache行为，如对一个select语句不用缓存，useCahce="false"
MyBatis还支持其他第三方缓存（这个不用管，用默认就行）


第四章 使用注解配置SQL映射器（了解）
public interface StudentMapper { 
	@Insert("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,ADDR_ID, PHONE) VALUES(#{studId},#{name},#{email},#{address.addrId},#{phone})") 
	int insertStudent(Student student); 
}
基本类似于上面的写法，觉得这个用的不多，因为MyBatis就是为了集中管理SQL语句，如果把SQL不放在xml里而是分散到各个类中，则不易管理


第五章 与Spring集成
MyBatis-Spring是MyBatis框架的子模块，用来与Spring框架对接
1.在Spring中配置MyBatis
Maven pom.xml
<dependency>
	<groupId>org.mybatis</groupId>
	<artifactId>mybatis-spring</artifactId>
	<version>1.2.0</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context-support</artifactId>
	<version>3.1.3.RELEASE</version>
	<exclusions>
		<exclusion>
			<groupId>commons-logging</groupId>
			<artifactId>commons-logging</artifactId>
		</exclusion>
	</exclusions>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-jdbc</artifactId>
	<version>3.1.3.RELEASE</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-test</artifactId>
	<version>3.1.3.RELEASE</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>org.aspectj</groupId> 
	<artifactId>aspectjrt</artifactId> 
	<version>1.6.8</version> 
</dependency>
<dependency> 
	<groupId>org.aspectj</groupId> 
	<artifactId>aspectjweaver</artifactId> 
	<version>1.6.8</version> 
</dependency>
<dependency> 
	<groupId>cglib</groupId> 
	<artifactId>cglib-nodep</artifactId> 
	<version>2.2</version> 
</dependency>
<dependency> 
	<groupId>commons-dbcp</groupId> 
	<artifactId>commons-dbcp</artifactId> 
	<version>1.4</version> 
</dependency>
如果只用MyBatis，在每一个方法中，都要手动创建SqlSessionFactory对象，在重SqlSessionFactory对象中创建SqlSession，而且还要负责提交，回滚，关闭SqlSession对象。
用MyBatis-Spring模块，可以在Spring配置文件ApplicationContext中配置MyBatis Beans，Spring会负责实例化SqlSessionFactory对象及创建SqlSession对象，并将其注入到DAO或者Service类中。而且可以用Spring基于注解的事务管理功能，不用自己在数据访问层写事务处理代码

2. 配置MyBatis Beans
ApplicationContext.xml
<beans>
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/elearning" />
		<property name="username" value="root" />
		<property name="password" value="admin" />
	</bean>
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="typeAliases" value="com.mybatis3.domain.Student, com.mybatis3.domain.Tutor" />
		<property name="typeAliasesPackage" value="com.mybatis3.domain" />
		<property name="typeHandlers" value="com.mybatis3.typehandlers.PhoneTypeHandler" />
		<property name="typeHandlersPackage" value="com.mybatis3.typehandlers" />
		<property name="mapperLocations" value="classpath*:com/mybatis3/**/*.xml" />
		<property name="configLocation" value="WEB-INF/mybatisconfig.xml" />
	</bean>
</beans>
使用上述的 bean 定义，Spring 会使用如下配置属性创建一个 SqlSessionFactory 对象：
dataSource:它引用了 dataSource bean
typeAliases:它指定了一系列的完全限定名的类名列表，用逗号隔开，这些别名将通过默认的别名规则创建
（将首字母小写的非无完全限定类名作为别名）。
typeAliasesPackage:它指定了一系列包名列表，用逗号隔开，包内含有需要创建别名的 JavaBeans。
typeHandlers:它指定了一系列的类型处理器类的完全限定名的类名列表，用逗号隔开。
typeHandlersPackage: 它指定了一系列包名列表，用逗号隔开，包内含有需要被注册的类型处理器类。
mapperLocations:它指定了 SQL 映射器 Mapper XML 配置文件的位置
configLocation:它指定了 MyBatisSqlSessionFactory 配置文件所在的位置。

3.使用SqlSession
一旦 SqlSessionFactory bean 被配置，我们需要配置 SqlSessionTemplate bean，SqlSessionTemplate bean
是一个线程安全的 Spring bean，我们可以从中获取到线程安全的 SqlSession 对象。由于 SqlSessionTemplate 提
供线程安全的 SqlSession 对象，你可以在多个 Spring bean 实体对象中共享 SqlSessionTemplate 对象。从概念上
看，SqlSessionTemplate 和 Spring 的 DAO 模块中的 JdbcTemplate 非常相似。
<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
	<constructor-arg index="0" ref="sqlSessionFactory" />
</bean>

//SqlSession的Factory之类都有Spring弄好了，直接用就行
public class StudentDaoImpl implements StudentDao
{
	private SqlSession sqlSession;//SqlSession是接口，注入SqlSessionTemplate是它的实现类
	public void setSqlSession(SqlSession session)//set注入，需要xml配置，这里没有写
	{
		this.sqlSession = session;
	}
	public void createStudent(Student student)
	{
		StudentMapper mapper =
		this.sqlSession.getMapper(StudentMapper.class);
		mapper.insertStudent(student);
	}
}

还有另外一种注入 Sqlsession 对象的方法，即，通过拓展继承 SqlSessionDaoSupport。这种方式让我们可以在
执行映射语句时，加入任何自定义的逻辑。
<bean id="studentMapper" class="com.mybatis3.dao.StudentMapperImpl">
	<property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>

public class StudentMapperImpl extends SqlSessionDaoSupport 
	implements StudentMapper
{
	public void createStudent(Student student) {
		StudentMapper mapper =
		getSqlSession().getMapper(StudentMapper.class);
		mapper.insertAddress(student.getAddress());
		//Custom logic
		mapper.insertStudent(student);
	}
}
在以上的这些方式中，我们注入了 SqlSession 对象，获取 Mapper 实例，然后执行映射语句。这里 Spring 会为我
们提供一个线程安全的 SqlSession 对象，以及当方法结束后关闭 SqlSession 对象。
然而，MyBatis-Spring 模块提供了更好的方式，我们可以不通过 SqlSession 获取映射器 Mapper，直接注射 Sql映射器 Mapper bean。我们下节将讨论它。

4.使用映射器
我们可以使用 MapperFactoryBean 将映射器 Mapper 接口配置成 Spring bean 实体。如下所示：
<bean id="studentMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
	<property name="mapperInterface" value="com.mybatis3.mappers. StudentMapper" />
	<property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>

public interface StudentMapper
{
	@Select("select stud_id as studId, name, email, phone from
	students where stud_id=#{id}")
	Student findStudentById(Integer id);
}

现在 StudentMapper bean 实体对象可以被注入到任意的 Spring bean 实体对象中并调用映射语句方法，如下所
示：
<bean id="studentService" class="com.mybatis3.services.StudentService">
	<property name="studentMapper" ref="studentMapper" />
</bean>

public class StudentService
{
	private StudentMapper studentMapper;
	public void setStudentMapper(StudentMapper studentMapper) {
		this. studentMapper = studentMapper;
	}
	public void createStudent(Student student) {
		this.studentMapper.insertStudent(student);
	}
}

分别配置每一个映射器 Mapper 接口是一个非常单调的过程。我们可以使用 MapperScannerConfigurer 来扫描包
（package）中的映射器 Mapper 接口，并自动地注册。
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value="com.mybatis3.mappers" />
</bean>

如果映射器 Mapper 接口在不同的包(package)中，你可以为 basePackage 属性指定一个以逗号分隔的包名列表。
MyBatis-Spring-1.2.0 介绍了两种新的扫描映射器 Mapper 接口的方法：
 使用<mybatis:scan/>元素
 使用@MapperScan 注解（需 Spring3.1+版本）

5.Mapper扫描
(1)<mybatis:scan />
<mybatis:scan>元素将在特定的以逗号分隔的包名列表中搜索映射器 Mapper 接口。使用这个新的 MyBatisSpring
名空间你需要添加以下的 schema 声明：
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:mybatis="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://mybatis.org/schema/mybatis-spring
		http://mybatis.org/schema/mybatis-spring.xsd">
	<!--应该主要是这个-->
	<mybatis:scan base-package="com.mybatis3.mappers" />
</beans>
<mybatis:scan>元素提供了下列的属性来自定义扫描过程：
annotation: 扫描器将注册所有的在 base-package 包内并且匹配指定注解的映射器 Mapper 接口。
factory-ref: 当 Spring 上 下 文 中 有 多 个 SqlSessionFactory 实 例 时 ， 需 要 指 定 某 一 特 定 的
SqlSessionFactory 来创建映射器 Mapper 接口。正常情况下，只有应用程序中有一个以上的数据源
才会使用。
marker-interface: 扫描器将注册在 base-package 包中的并且继承了特定的接口类的映射器 Mapper 接口。
template-ref: 当 Spring 上下文中有多个 SqlSessionTemplate 实例时，需要指定某一特定的
SqlSessionTemplate 来创建映射器 Mapper 接口。正常情况下，只有应用程序中有一个以上的数据源
才会使用。
name-generator:BeannameGenerator 类的完全限定类名，用来命名检测到的组件。

(2)MapperScan
Spring 框架 3.x+版本支持使用@Configuration 和@Bean 注解来提供基于 Java 的配置。如果你倾向于使用基于
Java 的配置，你可以使用@MapperScan 注解来扫描映射器 Mapper 接口。@MapperScan 和<mybatis:scan/>工作方式
相同，并且也提供了对应的自定义选项。
@Configuration
@MapperScan("com.mybatis3.mappers")
public class AppConfig
{
	@Bean
	public DataSource dataSource() {
		return new PooledDataSource("com.mysql.jdbc.Driver",
		"jdbc:mysql://localhost:3306/elearning", "root", "admin");
	}
	@Bean
	public SqlSessionFactory sqlSessionFactory() throws Exception {
		SqlSessionFactoryBeansessionFactory = new SqlSessionFactoryBean();
		sessionFactory.setDataSource(dataSource());
		return sessionFactory.getObject();
	}
}
@MapperScan 注解有以下属性供自定义扫描过程使用:
annotationClass: 扫描器将注册所有的在 base-package 包内并且匹配指定注解的映射器 Mapper 接口。
markerInterface: 扫描器将注册在 base-package 包中的并且继承了特定的接口类的映射器 Mapper 接口
sqlSessionFactoryRef:当 Spring 上下 文 中有一个以上的 SqlSesssionFactory 时，用来指定特 定
SqlSessionFactory
sqlSessionTemplateRef: 当 Spring 上下文中有一个以上的 sqlSessionTemplate 时，用来指定特定
sqlSessionTemplate
nameGenerator:BeanNameGenerator 类用来命名在 Spring 容器内检测到的组件。
basePackageClasses:basePackages()的类型安全的替代品。包内的每一个类都会被扫描。
basePackages:扫描器扫描的基包，扫描器会扫描内部的 Mapper 接口。注意包内的至少有一个方法声明的才会被
注册。具体类将会被忽略。

与注入 Sqlsession 相比，更推荐使用注入 Mapper，因为它摆脱了对MyBatis API 的依赖。
(注：还是先考虑正确性，先用熟悉的明显的方法，如果某个方法不熟悉不肯定，则不要用，因为容易有坑)

6.用Spring进行事务管理
只使用 MyBatis，你需要写事务控制相关代码，如提交或者回退数据库操作。
public Student createStudent(Student student)
{
	SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().
	openSession();
	try
	{
		StudentMapper mapper =
		sqlSession.getMapper(StudentMapper.class);
		mapper.insertAddress(student.getAddress());
		mapper.insertStudent(student);
		sqlSession.commit();
		return student;
	}
	catch (Exception e)
	{
		sqlSession.rollback();
		throw new RuntimeException(e);
	}
	finally
	{
		sqlSession.close();
	}
}

我们可以使用 Spring 的基于注解的事务处理机制来避免书写上述的每个方法中控制事务的冗余代码。
为了能使用 Spring 的事务管理功能，我们需要在 Spring 应用上下文中配置 TransactionManager bean 实体对象：
<bean id="transactionManager"
class="org.springframework.jdbc. datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource" />
</bean>

在 Spring 中使用基于注解的事务管理特性，如下：
<tx:annotation-driven transaction-manager="transactionManager"/>
现在你可以在 Spring service bean 上使用@Transactional 注解，表示在此 service 中的每一个方法都应该在
一个事务中运行。如果方法成功运行完毕，Spring 会提交操作。如果有运行期异常发生，则会执行回滚操作。另外，
Spring 会将 MyBatis 的异常转换成合适的 DataAccessExceptions，这样会为特定错误上提供额外的信息。
@Service
@Transactional
public class StudentService
{
	@Autowired
	private StudentMapper studentMapper;
	public Student createStudent(Student student)
	{
		studentMapper.insertAddress(student.getAddress());
		if(student.getName().equalsIgnoreCase(""))
		{
			throw new RuntimeException("Student name should not be empty.");
		}
		studentMapper.insertStudent(student);
		return student;
	}
}

下面是一个 Spring 的 applicationContext.xml 完成配置：
<beans>
	<context:annotation-config />
	<context:component-scan base-package="com.mybatis3" />
	<context:property-placeholder location="classpath:application.properties" />
	<tx:annotation-driven transaction-manager="transactionManager" />
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.mybatis3.mappers" />
	</bean>
	<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg index="0" ref="sqlSessionFactory" />
	</bean>
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="typeAliases" value="com.mybatis3.domain.Student,com.mybatis3.domain.Tutor" />
		<property name="typeAliasesPackage" value="com.mybatis3.domain" />
		<property name="typeHandlers" value="com.mybatis3.typehandlers.PhoneTypeHandler" />
		<property name="typeHandlersPackage" value="com.mybatis3.typehandlers" />
		<property name="mapperLocations" value="classpath*:com/mybatis3/**/*.xml" />
	</bean>
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}"></property>
		<property name="url" value="${jdbc.url}"></property>
		<property name="username" value="${jdbc.username}"></property>
		<property name="password" value="${jdbc.password}"></property>
	</bean>
</beans>

一个独立的测试客户端来测试 StudentService：
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext.xml")
public class StudentServiceTest {
	@Autowired
	private StudentService studentService;
	@Test
	public void testCreateStudent() {
		Address address = new Address(0, "Quaker RidgeRd.", "Bethel", "Brooklyn", "06801", "USA");
		Student stud = new Student();
		long ts = System.currentTimeMillis();
		stud.setName("stud_" + ts);
		stud.setEmail("stud_" + ts + "@gmail.com");
		stud.setAddress(address);
		Student student = studentService.createStudent(stud);
		assertNotNull(student);
		assertEquals("stud_" + ts, student.getName());
		assertEquals("stud_" + ts + "@gmail.com", student.getEmail());
		System.err.println("CreatedStudent: " + student);
	}
	@Test(expected = DataAccessException.class)
	public void testCreateStudentForException() {
		Address address = new Address(0, "Quaker RidgeRd.", "Bethel", "Brooklyn", "06801", "USA");
		Student stud = new Student();
		long ts = System.currentTimeMillis();
		stud.setName("Timothy");
		stud.setEmail("stud_" + ts + "@gmail.com");
		stud.setAddress(address);
		studentService.createStudent(stud);
		fail("You should not reach here");
	}

}
这里在 testCreateStudent()方法中，我们为 Address 和 Student 赋上了合适的数据，所以 Address 和 Student
会被分别插入到表 ADDRESSES 和 STUDENTS 中。在 testCreateStudentForException()方法我们设置了名字为
Timothy，该名称在数据库中已经存在了，所以当你尝试将此 student 记录插入到数据库中，MySQL 会抛出一个 UNIQUE
KEY 冲突的异常，Spring 会将此异常转换成 DataAccessException 异常，并且将插入 ADDRESSES 表中的数据回滚
（rollback）掉。

/*******************************The End*******************************/