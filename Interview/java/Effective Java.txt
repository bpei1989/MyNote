第一章： 引言
规则不会百分之百地使用于任何时刻和场合，但是，它们确实体现了绝大多数情况下的最佳程序设计实践。你不应该盲目地遵从这些规则，但是，你应该只在偶尔的情况下，有充分的理由之后才去打破这些规则。同大多数学科一样，编程首先要学会基本规则，然后才能知道什么时候可以打破这些规则。
本书大部分内容不是讨论性能的，而是关心如何编写出清晰，正确，可用，健壮，灵活和可维护的程序，如果能做到这一点的话，性能往往会比较容易获取。（注：因为只有做到清晰正确可用可维护，才可能调优，反过来，一般做到这几点的，性能也不会差到哪儿去）



第二章： 创建和销毁对象
第一条，	考虑用静态工厂方法替代构造器
例如：如果HashMap有静态工厂方法，就可以这么写：
public static <K, V> HashMap<K, V> newInstance() {
	return new HashMap<K, V>();
}

Map<String, List<String>> m = HashMap.newInstance();

静态工厂方法其实就是返回一个实例，不用公用构造器，可以起其他名字，比如valueOf

静态工厂方法的优点： 静态工厂方法有名称，更准确描述返回对象； 直接调用，因为是静态方法； 可以返回原返回类型的任何子类型的对象，更灵活； 创建对象是代码简洁
缺点： 不能子类化，需要辅助公用构造器才行
总结：静态工厂方法和公有构造器各有用处，但静态工厂方法往往更适用，所以不要第一反应是公有的构造器，而是要考虑用静态工厂方法


第二条， 遇到多个构造器参数时要考虑用构建器（Builder）
参数过多时，就得用多个构造器，分别对应不同的参数来创建类，可是这样比较繁琐，而且可读性差，如果用JavaBean模式，调用一个无参构造器，然后调用setter方法，但这种方法可能会有线程安全的问题，因为setter是分别进行的

Builder是让客户端利先获取到一个builder对象，然后客户端在builder对象上调用类似于setter的方法，设置各个参数，最后，客户端调用无参的build方法生成对象
public class NutritionFacts {
	private final int servingSize;
	private final int servings;
	private final int calories;
	private fianl int fat;
	private final int sodium;
	private final int carbohydrate;

	public static class Builder {
		//Required params
		private final int servingSize;
		private final int servings;

		//optional params
		private final int calories;
		private fianl int fat;
		private final int sodium;
		private final int carbohydrate;

		public Builder(int servingSize, int servings) {
			this.servingSiZe = servingSize;
			this.servings = servings;
		}

		public Builder calories(int val) {
			calories = val;
			return this;
		}
		public Builder fat(int val) {
			fat = val;
			return this;
		}
		public Builder carbohydrate(int val) {
			carbohydrate = val;
			return this;
		}
		public Builder sodium(int val) {
			sodium = val;
			return this;
		}

		public NutritionFacts build() {
			return new NutritionFacts(this);
		}
	}

	private NutritionFacts(Builder builder) {
		servingSize = builder.servingSize;
		servings = builder.servings;
		calories = builder.calories;
		fat = builder.fat;
		sodium = builder.sodium;
		carbohydrate = builder.carbohydrate;
	}
}

builder的setter方法返回builder本身，这样就可以链接调用
NutritionFacts coke = new NutritionFacts.Builder(240, 8).
	calories(100).sodium(35).carbohydrate(27).build();

这样客户端易于阅读，编写，builder模拟了用名字选择参数，类似python的reboot=false

设置参数的builder就是一个很好的抽象工厂，客户端把这个builder当作方法的参数，这个方法就能够为客户端创建一个或者多个对象，但首先需要有个泛型来表示builder的类型
public inerface Builder<T> {
	public T build();
}

Tree buildTree(Builder<? extends Node> nodeBuilder) {...}
nodeBuilder实现了Builder，这个Builder可以set各个参数，而且有build函数返回实例，即负责产生类的对象并返回，客户端只需要调用即可，其实就是一个工厂，而且基于接口和泛型，支持多种类型的构建，就是抽象工厂，比如可以生产任何继承自Node的子类的对象

总结：如果类的构造器或静态工厂中具有多个参数，用Builder模式（更易读，更易写，更安全），比如http包头，soap包头，这些都有很多可选的参数，这也是citrus中构造协议包头部分用了很多Builder的原因（可以看citrus的源码，更深入了解Builder模式）


第三条， 用私有构造器或者枚举类型强化Singleton属性
单例模式的实现
方法1： public static final
public class Elvis {
	public static final Elvis INSTANCE = new Elvis(); //公有静态final类型的Instance来实现单例模式
	private Elvis() {...}

	public void leaveTheBuilding() { ... }
}
通过反射调用私有构造器可能会产生多个对象，这个方法不是最佳

方法2： 静态工厂方法
public class Elvis{
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() {...}
	public static Elvis getInstance() { return INSTANCE; } //静态方法返回

	public void leaveTheBuilding() { ... }
}
与方法1的区别就是返回单例用的是getInstance，单例本身是private，优势是：与第一条静态工厂方法的优势一样，即不用构造器而用静态工厂方法

方法3： 单个元素的枚举类型
public enum Elvis {
	INSTANCE;

	public void leaveTheBuilding() {...}
}
更简洁
总结：其实个人认为第二个方法最好，最常规，容易记，第三个方法虽然简单，但是有些偏，还是用正常的东西最好


第四条， 通过私有构造器强化不可实例化
有的类不需要实例化，比如各种工具类，直接classname.method就行，不需要new出来
创建不可实例化的类
public class Utility {
//这里加注释解释下为什么不可实例化，不然看起来就很费解
	private Utility() {
		throw new AssertionError();
	}
	...
}
通过声明一个private的构造函数来加强不可实例化的类


第五条， 避免创建不必要的对象
用静态尽量不用重复new，用基本类型，如int，尽量不用装箱类型，如Integer

String s = new String("abc"); //DOＮ'Ｔ　ＤＯ　ＴＨＩＳ
每次都新建一个String

String s = "abc"; //正确

//重复创建对象，耗费资源，不可用
public class Person {
	private final Date birthDate;

//每次都新建Calendar，TimeZone，效率低
	public boolean isBabyBoomer() {
		Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
		gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
		Date boomStart = gmtCal.getTime();
		gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
		Date boomEnd = gmtCal.getTime();
		return birthDate.compareTo(boomStart) >= 0 &&
				birthDate.compareTo(booEnd) < 0
	}
}

//高效正确版本
Class Person {
	private final Date birthDate;

//静态一般用大写和下划线，这点要注意
	private static final Date BOOM_START;
	private static final Date BOOM_END;

//注意，static还可修饰代码块
	static {
		Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));//第一条，静态工厂方法
		gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
		BOOM_START = gmtCal.getTime();
		gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
		BOOM_END = gmtCal.getTime();
	}

	public boolean isBabyBoomer() {
			return birthDate.compareTo(BOOM_START) >= 0 &&
			birthDate.compareTo(BOOM_END) < 0
	}
}
一个类可以使用不包含在任何方法体中的静态代码块，当类被载入时，静态代码块被执行，且只被执行一次，静态块常用来执行类属性的初始化。例如：
static {...}
改进后只是在初始化时创建Calendar，TimeZone等

适配器是指一个对象，它把功能委托给一个backing object，而为backing object提供一个可替代的接口，针对特定对象的适配器，没必要创建多个
比如Map的接口keySet方法返回Map对象的Set视图，其中包含Map中所有的key，看起来好像每次调用keySet都会返回一个新建的Set实例，但其实对一个给定的Map对象，每次调用keySet都返回同样的Set实例，当其中一个返回对象发生改变，其他的返回对象也要变化

自动装箱时基本类型和装箱类型自动转换，比如long和Long
public static void main(String args) {
	Long sum = 0;
	for(long i=0; i<max; i++) {
		sum += i;
	}
}
因为是Long，所以每个循环都会新建一个Long的对象
优先使用基本类型


第六条，消除过期对象的引用
如果对象的引用没有被清除，则可能引起内存泄露，内存泄露会导致运行缓慢，甚至OutOfMemoryError

public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 10;

	public Stack() {
		elements = new Object[];
	}

	public void push(Object e) {
		ensureCapacity();
		elements[size++] = e;
	}

	public Object pop() {
		if (size == 0) {
			throw new EmptyException();
		}
		return elements[--size]; //这里引用并没有清空，虽然弹出了
	}

	private void ensureCapacity() {
		if (elements.length == size)
			elements = Arrays.copyOf(elements, 2*size + 1); //检查栈空间，不够就加倍
	}
}
程序可以运行，但长时间运行会导致内存泄露
//清除弹出的元素引用
public Object pop() {
	if (size == 0)
		throw new EmptyException();
	Object result = elements[--size];
	elements[size] = null; //清空元素引用
	return result;
}

如果是自己管理的内存部分，比如自己申请的栈，就要注意内存泄露，解决方案就是清空引用

内存泄露的另一个主要来源是缓存，放入后忘记，可以用WeakHashMap，WeakHashMap，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值
还有就是注册的监听和回调，没有注销监听


第七条，避免使用终结方法
不要使用默认的finalizer，收尾:每个类都有一个特殊的方法finalizer，它不能被直接调用，而被JVM在适当的时候调用，通常用来处理一些清理资源的工作，因此称为收尾机制，因为finalizer的的缺点在于不能保证会及时的执行，因为JVM会延迟执行终结方法，导致大量有限资源不能释放，比如数据库session；还有一点终结方法很消耗资源，比创建慢400多倍；还有可能引用没有释放掉，导致垃圾回收没有回收这个对象，资源无法释放
正确的做法是：
1. try-finally结构，在finally里调用终止方法
Foo foo = new Foo(...);
try{
	...
} finally {
	foo.terminate() //比如io.close
}
这样做可以防止前面忘记调用终止方法，finally可以保障关闭（FileInputStream，FileOutputStream，Timer，Connection）
还有一点要注意，如果子类覆盖了父类的finalize方法，则需要显示调用，否则父类终结方法不会被调用
@Override
protected void finalize() throws Throwable {
	try{
		...
	} finally {
		super.finalize();
	}
}
如果都没有重写过finalize方法就没必要显示调用了
注解：基本上可以说，不要让类自己释放那些有限资源，比如io，要在finally里显式调用，如果有重写过finalize方法，需super（一般不会重写）



第三章: 对于所有对象都通用的方法
第八条，覆盖equals时请遵守通用约定
一般不要覆盖equals，因为可能会导致很严重的错误，但类具有自己独特的相等概念就需要覆盖equals
约定：
自反性：任何非null引用x，x.equals(x)返回true
对称性：任何非null引用值x和y，y.equals(x)为true，则x.equals(y)为true
传递性：任何非null引用值x，y，z，如果x.equals(y)为true,y.equals(z)为true,则x.equals(z)为true
一致性：任何非null引用值x和y，多次调用x.equals(y)都会返回true

equals方法编写诀窍：
1. 使用==检查参数是否为这个对象的引用，如果是返回true（这个应该是对应第一条，自反性）
2. 使用instanceof坚持参数是否为正确类型
if(!(o instanceof MyType))
	return false;
3. 把参数转换成正确类型，因为进行过instanceof，所以能转换成功
4. 对于类的每个关键变量，检查参数中的是否和对象中的相匹配

由于第1条规定了自反性，所以编写好之后看是否对称，传递，一致
还有覆盖equals总要覆盖hashCode，不要让equals过于复杂，容易出错，简洁些；不要把equals声明中的Object对象替换为其他类型，如：
public boolean equals(MyType o) {
	...
}
这个方法没有覆盖Object.equals，因为参数不是Object，它只是重载了Object.equals方法，所以用Override
@Override
public boolean equals(MyType o){
	...
}
（注解：正因为传进来的是Object，所以才需要instanceof还有转换）


第九条，覆盖equals时总要覆盖hashCode
如果没有覆盖hashCode method，则HashMap，Hashtable之类都不用
相等的对象必须有相等的HashCode
按照第八条写的equals
@Override 
public boolean equals(Object o) {
	if(o == this)
		return true;
	if(!(o instanceof PhoneNumber))
		return false;
	PhoneNumber pn = (PhoneNumber)o;
	return pn.lineNumber == lineNumber
		&& pn.prefix == prefix
		&& pn.areaCode == areaCode;
}

然后HashMap保存
Map<PhoneNumber, String> m = new HashMap<PhoneNumber, String>();
m.put(new PhoneNumber(707,867,5397),"jenny");
用m.get（new PhoneNumber(707,867,5397)）取的时候返回null，而不是jenny，
因为没有PhoneNumber类没有覆盖HashCode方法，导致两个相等实例具有不同HashCode，所以put方法把对象放到一个Hash bucket里，取的时候又到另一个Hash bucket里

@Override
public int hashCode() {return 11;}
上面函数一定能工作，但没有意义，因为把所有都放到11号hash bucket中，导致哈希变成列表，效率低
一般写hash用result = 31*result + c
@Override
public int hashCode() {
	int result = 17;
	result = 31*result + areaCode;
	result = 31*result + prefix;
	result = 31*result + lineNumber;
	return result;
}

有的计算散列开销大，而且类不变时可以考虑把hashCode放到类中，每次到hashCode第一次被调用时才会加载，用volatitle
private volatile int hashCode; //Lazyliy initialize

@Override
public int hashCode() {
	int result = hashCode;
	if (result == 0) {
		result = 31*result + areaCode;
		result = 31*result + prefix;
		result = 31*result + lineNumber;
		hashCode = result;
	}
	return result;
}


第十条，始终要覆盖toString
好的toString可以让类用起来更方便， toString返回对象中包含的所有值得关注的信息
@Override public String toString() {
	return String.formate("(%03d) %03d-%04d".
							areaCode, prefix, lineNumber);
}


第十一条， 谨慎覆盖clone
Object的clone方法是protected的，如果不用反射，就不能仅仅因为实现了Cloneable就调用clone方法，因为不能保证对象拥有一个可访问的clone方法
clone方法用于深拷贝
方法1： 调用super.clone,然后递归地深拷贝每个元素
每个实现了Cloneable接口的类都要有一个公有方法覆盖clone，这个公有方法先调用super.clone，然后对每个元素递归clone
@Override public HashTable clone() {
	try {
		HashTable result = (HashTable)super.clone();
		result.buckets = new Entry[buckets.length];
		for(int i=0; i<buckets.length; i++)
			if (result.buckets[i]!=null) {
				result.buckets[i] = buckets[i].deepCopy(); //deepCopy是新建一个对象，然后把原来对象的值放到构造函数里构造出新对象
			}
			return result;
	} catch (CloneNotSupportedException e) {
		throw xxx
	}
}

方法2： 先调用super.clone，再把结果对象中的所有的item都设置为空白，调用构造方法来生成新的对象，然后再put，这样比较清楚，但这样没有递归调用clone效率高

方法3： 拷贝构造器
public static Yun newInstance(Yun yun);
完全根据各个值new出一个新的，比clone方法有优势，风险低，不必遵守很多既定的规范，不会有一些异常发生

注解：Cloneable有很多问题，clone方法坑也很多，尽量不要用，如果费用不可，就用方法2或方法3，用new的方式，而不要用递归clone，因为有风险，可能有Exception


第十二条， 考虑实现Comparable接口
实现Comparable接口的类，可以用集合的方法，比如sort
public final class CaseInsensitiveString
	implements Comparable<CaseInsensitiveString> { //实现Comparable接口，而且泛型写法要注意
	public int compareTo(CaseInsensitiveString cis) { //compareTo函数，参数是要比较的类本身，而不是Object
		return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s); //<0小于，>0大于，0等于
	}
}



第四章：类和接口
第十三条， 使类和成员的可访问性最小化
良好的模块会隐藏所有实现细节，隔离API与具体实现，模块之间只通过API通信，解除模块间的耦合，可以独立开发，测试，修改
有公有API后，几乎所有成员变量都该是私有，除非当同一个包内另一个类需要访问一个成员，则删除private变为包级别私有
注解：尽量降低可访问性，除了公有静态final外，公有类不应该有public的成员变量，而且static final引用对象要不可变，主要是为了防止模块之间的依赖，如果public成员变量，类之间的耦合就会增加


第十四条， 在公有类中使用访问方法而非公有变量
就是用get方法，set方法，而不是用public成员变量，但如果不是public类，是包级别私有或嵌套类，则public成员变量没有本质错误


第十五条， 使可变性最小化
为了使类不可变，或尽量少变化，需要遵循的原则：
1. 不提供任何修改对象状态的方法（如set方法）
2. 保证类不会扩展（生命为final）
3. 多用final
4. 非final的是private
5. 可变组件互斥访问
注解：有些类可能需要这个，比如String，BigDecimal等


第十六条， 复合比继承优先
跨包继承打破了封装性，子类依赖于父类中特定的细节，厄尔父类实现可能会随着版本变化，这样子类会有问题，除非父类是专门为扩展设计的，比如Base类
复合has a，继承is a
class Car extends Veicle{ //继承
	private Wheel w; //复合
	private Engine e;
}
决定使用继承而不是复合之前，应该问一个问题，你继承的类，它的API有没有缺陷？继承会把超类API中的问题传播到子类中，复合则会允许新API隐藏缺陷
总结：继承很强大，但也存在问题。继承违背了封装原则，只有父类和子类之间确实存在类型关系时，继承可用，但父类和子类处于不同包中，而且父类不是为继承设计的，这种继承就很容易有问题，需用复合来，尤其有接口可以实现包装类时


第十七条， 为继承而设计，提供文档说明，否则就不用继承
原因和第十六条类似，比如测试中Base类就属于为继承而设计，这时就需要有很详细的文档注释


第十八条， 接口由于抽象类
Java只允许单继承，很大程度限制了抽象类，接口可以实现多个；但抽象类有个优势：如果后续版本中增加新方法，可以有默认实现，子类直接继承用就行，而接口就不行
最佳实践：用抽象类实现接口，Override公用的method，这样既可以让子类继承默认实现，也可以抽象类实现多个接口

//这种实现叫做Skeletal实现，必须有详细的注解，因为这是抽象类所需要有的
public abstract class AbstractMapEntry<K,V>
	implements Map.Entry<K,V> {
	public abstract K getKey();
	public abstract V getValue();

	public V setValue(V value) { //所有子类必须重写这个方法，否则根本无法存值
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean equals(Object o) { //注意equals的写法，三个步骤，== instanceof Object类型强制转换
		if(o == this)
			return false;
		if(!(o instanceof Map.Entry))
			return false;
		Map.Entry<?,?> arg = (Map.Entry) o;
		return equals(getKey(), arg.getkey() &&
				equals(getValue(), arg.getValue());
	}
	private static boolean equals(Object o1, Object o2) {
		return o1 == null ? o2 == null : o1.equals(o2);
	}

	@Ovveride
	public int hashCode() {
		return hashCode(getKey() ^ hashCode(getValue());
	}
	private static int hashCode(Object obj) {
		return obj == null ? 0 : obj.hashCode();
	}
}
注意上面这个实现，equals，hashCode，挑最常用的方法在抽象类中实现，子类可直接用，而抽象类又实现接口，实现接口优势和抽象类优势合并
总结：接口通常是定义允许多个实现类型的最佳途径。这条规则有个例外，当演变的容易性比灵活性和功能更重要的时候，这时应使用抽象类来定义类型。如果导出一个重要接口，就坚决考虑提供Skeletal实现，最后谨慎设计公有接口，并通过编写多个实现来全面测试


第十九条， 接口只用于定义类型
