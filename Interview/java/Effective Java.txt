引言
规则不会百分之百地使用于任何时刻和场合，但是，它们确实体现了绝大多数情况下的最佳程序设计实践。你不应该盲目地遵从这些规则，但是，你应该只在偶尔的情况下，有充分的理由之后才去打破这些规则。同大多数学科一样，编程首先要学会基本规则，然后才能知道什么时候可以打破这些规则。
本书大部分内容不是讨论性能的，而是关心如何编写出清晰，正确，可用，健壮，灵活和可维护的程序，如果能做到这一点的话，性能往往会比较容易获取。（注：因为只有做到清晰正确可用可维护，才可能调优，反过来，一般做到这几点的，性能也不会差到哪儿去）



创建和销毁对象
第一条，	考虑用静态工厂方法替代构造器
例如：如果HashMap有静态工厂方法，就可以这么写：
public static <K, V> HashMap<K, V> newInstance() {
	return new HashMap<K, V>();
}

Map<String, List<String>> m = HashMap.newInstance();

静态工厂方法其实就是返回一个实例，不用公用构造器，可以起其他名字，比如valueOf

静态工厂方法的优点： 静态工厂方法有名称，更准确描述返回对象； 直接调用，因为是静态方法； 可以返回原返回类型的任何子类型的对象，更灵活； 创建对象是代码简洁
缺点： 不能子类化，需要辅助公用构造器才行
总结：静态工厂方法和公有构造器各有用处，但静态工厂方法往往更适用，所以不要第一反应是公有的构造器，而是要考虑用静态工厂方法


第二条， 遇到多个构造器参数时要考虑用构建器（Builder）
参数过多时，就得用多个构造器，分别对应不同的参数来创建类，可是这样比较繁琐，而且可读性差，如果用JavaBean模式，调用一个无参构造器，然后调用setter方法，但这种方法可能会有线程安全的问题，因为setter是分别进行的

Builder是让客户端利先获取到一个builder对象，然后客户端在builder对象上调用类似于setter的方法，设置各个参数，最后，客户端调用无参的build方法生成对象
public class NutritionFacts {
	private final int servingSize;
	private final int servings;
	private final int calories;
	private fianl int fat;
	private final int sodium;
	private final int carbohydrate;

	public static class Builder {
		//Required params
		private final int servingSize;
		private final int servings;

		//optional params
		private final int calories;
		private fianl int fat;
		private final int sodium;
		private final int carbohydrate;

		public Builder(int servingSize, int servings) {
			this.servingSiZe = servingSize;
			this.servings = servings;
		}

		public Builder calories(int val) {
			calories = val;
			return this;
		}
		public Builder fat(int val) {
			fat = val;
			return this;
		}
		public Builder carbohydrate(int val) {
			carbohydrate = val;
			return this;
		}
		public Builder sodium(int val) {
			sodium = val;
			return this;
		}

		public NutritionFacts build() {
			return new NutritionFacts(this);
		}
	}

	private NutritionFacts(Builder builder) {
		servingSize = builder.servingSize;
		servings = builder.servings;
		calories = builder.calories;
		fat = builder.fat;
		sodium = builder.sodium;
		carbohydrate = builder.carbohydrate;
	}
}

builder的setter方法返回builder本身，这样就可以链接调用
NutritionFacts coke = new NutritionFacts.Builder(240, 8).
	calories(100).sodium(35).carbohydrate(27).build();

这样客户端易于阅读，编写，builder模拟了用名字选择参数，类似python的reboot=false

设置参数的builder就是一个很好的抽象工厂，客户端把这个builder当作方法的参数，这个方法就能够为客户端创建一个或者多个对象，但首先需要有个泛型来表示builder的类型
public inerface Builder<T> {
	public T build();
}

Tree buildTree(Builder<? extends Node> nodeBuilder) {...}
nodeBuilder实现了Builder，这个Builder可以set各个参数，而且有build函数返回实例，即负责产生类的对象并返回，客户端只需要调用即可，其实就是一个工厂，而且基于接口和泛型，支持多种类型的构建，就是抽象工厂，比如可以生产任何继承自Node的子类的对象

总结：如果类的构造器或静态工厂中具有多个参数，用Builder模式（更易读，更易写，更安全），比如http包头，soap包头，这些都有很多可选的参数，这也是citrus中构造协议包头部分用了很多Builder的原因（可以看citrus的源码，更深入了解Builder模式）


第三条， 用私有构造器或者枚举类型强化Singleton属性
单例模式的实现
方法1： public static final
public class Elvis {
	public static final Elvis INSTANCE = new Elvis(); //公有静态final类型的Instance来实现单例模式
	private Elvis() {...}

	public void leaveTheBuilding() { ... }
}
通过反射调用私有构造器可能会产生多个对象，这个方法不是最佳

方法2： 静态工厂方法
public class Elvis{
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() {...}
	public static Elvis getInstance() { return INSTANCE; } //静态方法返回

	public void leaveTheBuilding() { ... }
}
与方法1的区别就是返回单例用的是getInstance，单例本身是private，优势是：与第一条静态工厂方法的优势一样，即不用构造器而用静态工厂方法

方法3： 单个元素的枚举类型
public enum Elvis {
	INSTANCE;

	public void leaveTheBuilding() {...}
}
更简洁
总结：其实个人认为第二个方法最好，最常规，容易记，第三个方法虽然简单，但是有些偏，还是用正常的东西最好


第四条， 通过私有构造器强化不可实例化
有的类不需要实例化，比如各种工具类，直接classname.method就行，不需要new出来
创建不可实例化的类
public class Utility {
//这里加注释解释下为什么不可实例化，不然看起来就很费解
	private Utility() {
		throw new AssertionError();
	}
	...
}
通过声明一个private的构造函数来加强不可实例化的类


第五条， 避免创建不必要的对象
用静态尽量不用重复new，用基本类型，如int，尽量不用装箱类型，如Integer

String s = new String("abc"); //DOＮ'Ｔ　ＤＯ　ＴＨＩＳ
每次都新建一个String

String s = "abc"; //正确

//重复创建对象，耗费资源，不可用
public class Person {
	private final Date birthDate;

//每次都新建Calendar，TimeZone，效率低
	public boolean isBabyBoomer() {
		Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
		gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
		Date boomStart = gmtCal.getTime();
		gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
		Date boomEnd = gmtCal.getTime();
		return birthDate.compareTo(boomStart) >= 0 &&
				birthDate.compareTo(booEnd) < 0
	}
}

//高效正确版本
Class Person {
	private final Date birthDate;

//静态一般用大写和下划线，这点要注意
	private static final Date BOOM_START;
	private static final Date BOOM_END;

//注意，static还可修饰代码块
	static {
		Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));//第一条，静态工厂方法
		gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
		BOOM_START = gmtCal.getTime();
		gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
		BOOM_END = gmtCal.getTime();
	}

	public boolean isBabyBoomer() {
			return birthDate.compareTo(BOOM_START) >= 0 &&
			birthDate.compareTo(BOOM_END) < 0
	}
}
一个类可以使用不包含在任何方法体中的静态代码块，当类被载入时，静态代码块被执行，且只被执行一次，静态块常用来执行类属性的初始化。例如：
static {...}
改进后只是在初始化时创建Calendar，TimeZone等

适配器是指一个对象，它把功能委托给一个backing object，而为backing object提供一个可替代的接口，针对特定对象的适配器，没必要创建多个
比如Map的接口keySet方法返回Map对象的Set视图，其中包含Map中所有的key，看起来好像每次调用keySet都会返回一个新建的Set实例，但其实对一个给定的Map对象，每次调用keySet都返回同样的Set实例，当其中一个返回对象发生改变，其他的返回对象也要变化

自动装箱时基本类型和装箱类型自动转换，比如long和Long
public static void main(String args) {
	Long sum = 0;
	for(long i=0; i<max; i++) {
		sum += i;
	}
}
因为是Long，所以每个循环都会新建一个Long的对象
优先使用基本类型


第六条，消除过期对象的引用
如果对象的引用没有被清除，则可能引起内存泄露，内存泄露会导致运行缓慢，甚至OutOfMemoryError

public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 10;

	public Stack() {
		elements = new Object[];
	}

	public void push(Object e) {
		ensureCapacity();
		elements[size++] = e;
	}

	public Object pop() {
		if (size == 0) {
			throw new EmptyException();
		}
		return elements[--size]; //这里引用并没有清空，虽然弹出了
	}

	private void ensureCapacity() {
		if (elements.length == size)
			elements = Arrays.copyOf(elements, 2*size + 1); //检查栈空间，不够就加倍
	}
}
程序可以运行，但长时间运行会导致内存泄露
//清除弹出的元素引用
public Object pop() {
	if (size == 0)
		throw new EmptyException();
	Object result = elements[--size];
	elements[size] = null; //清空元素引用
	return result;
}

如果是自己管理的内存部分，比如自己申请的栈，就要注意内存泄露，解决方案就是清空引用

内存泄露的另一个主要来源是缓存，放入后忘记，可以用WeakHashMap，WeakHashMap，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值
还有就是注册的监听和回调，没有注销监听


第七条，避免使用终结方法